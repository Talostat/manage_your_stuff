<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‰©ä»¶å„²å­˜ç®¡ç†ç³»çµ±</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app-container">
        <!-- é ‚éƒ¨æ¨™é¡Œæ¬„ -->
        <header class="app-header">
            <h1>ğŸ“¦ ç‰©ä»¶å„²å­˜ç®¡ç†ç³»çµ±</h1>
            <!-- çµ±è¨ˆä¿¡æ¯ -->
            <div class="header-stats">
                <div class="header-stat-item">
                    <span class="header-stat-icon">ğŸ </span>
                    <span class="header-stat-number" id="headerTotalRoots">0</span>
                    <span class="header-stat-label">åœ°é»</span>
                </div>
                <div class="header-stat-item">
                    <span class="header-stat-icon">ğŸ“¦</span>
                    <span class="header-stat-number" id="headerTotalNodes">0</span>
                    <span class="header-stat-label">å®¹å™¨</span>
                </div>
                <div class="header-stat-item">
                    <span class="header-stat-icon">ğŸ”–</span>
                    <span class="header-stat-number" id="headerTotalLeafs">0</span>
                    <span class="header-stat-label">ç‰©ä»¶</span>
                </div>
            </div>
            <div class="header-actions">
                <button class="btn btn-icon" onclick="exportToJSON()">ğŸ’¾ å°å‡º</button>
                <button class="btn btn-icon" onclick="document.getElementById('importFile').click()">ğŸ“‚ å°å…¥</button>
                <button class="btn btn-icon" onclick="restoreTemplate()">ğŸ”„ é‚„åŸç¯„æœ¬</button>
                <button class="btn btn-icon btn-danger" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…ç©º</button>
            </div>
            <input type="file" id="importFile" accept=".json" onchange="importData(event)" style="display: none;">
        </header>

        <!-- ä¸»è¦å…§å®¹å€ -->
        <div class="main-content">
            <!-- å·¦å´ï¼šåœ°é»åˆ—è¡¨ -->
            <div class="left-panel">
                <!-- çµ±è¨ˆå¡ç‰‡å·²ç§»åˆ° header ä¸­ -->
                <div class="stats-bar" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-icon">ğŸ </div>
                        <div class="stat-info">
                            <div class="stat-number" id="totalRoots">0</div>
                            <div class="stat-label">åœ°é»</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon">ğŸ“¦</div>
                        <div class="stat-info">
                            <div class="stat-number" id="totalNodes">0</div>
                            <div class="stat-label">å®¹å™¨</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon">ğŸ”–</div>
                        <div class="stat-info">
                            <div class="stat-number" id="totalLeafs">0</div>
                            <div class="stat-label">ç‰©ä»¶</div>
                        </div>
                    </div>
                </div>

                <!-- æœç´¢æ¬„ -->
                <div class="search-bar">
                    <input type="text" id="searchInput" class="search-input" placeholder="ğŸ” æœç´¢åœ°é»ã€å®¹å™¨æˆ–ç‰©ä»¶..." oninput="filterLocations(this.value)">
                </div>

                <!-- é¢æ¿æ¨ªå‘å®¹å™¨ -->
                <div class="panels-row">
                    <!-- åœ°é»åˆ—è¡¨ -->
                    <div class="tree-panel">
                        <div class="tree-header">
                            <h3>ğŸ  åœ°é»åˆ—è¡¨</h3>
                            <button class="btn-add-location" onclick="addNewLocation()">+ æ–°å¢åœ°é»</button>
                        </div>

                        <div class="locations-list" id="locationsList">
                            <!-- åœ°é»å¡ç‰‡å°‡å‹•æ…‹æ’å…¥ -->
                        </div>
                    </div>

                    <!-- è‡¨æ™‚å­˜å„²é¢æ¿ -->
                    <div class="temp-storage-container">
                        <div class="temp-storage-header">
                            <h3>ğŸ“‹ è‡¨æ™‚å­˜å„²</h3>
                        </div>
                        <div class="temp-storage-content" id="tempStorageList">
                            <!-- è‡¨æ™‚é …ç›®å°‡å‹•æ…‹æ’å…¥ -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- å³å´ï¼šæ•¸æ“šè¼¸å…¥è¡¨å–® -->
            <div class="right-panel">
                <div class="form-container">
                    <!-- æ¨™ç±¤é åˆ‡æ› -->
                    <div class="tab-header">
                        <button class="tab-button active" onclick="switchTab('form')" id="formTab">â• æ·»åŠ é …ç›®</button>
                        <button class="tab-button" onclick="switchTab('hierarchy')" id="hierarchyTab">ğŸŒ² å±¤ç´šæ§‹å»º</button>
                    </div>

                    <!-- è¡¨å–®æ¨™ç±¤é  -->
                    <div id="formTabContent" class="tab-content active">
                    <!-- ç·¨è¼¯æç¤º -->
                    <div class="edit-mode-banner" id="editBanner" style="display: none;">
                        <span id="editBannerText">âœï¸ æ­£åœ¨ç·¨è¼¯</span>
                        <button class="btn-close" onclick="cancelEdit()">âœ•</button>
                    </div>

                    <form class="vertical-form" id="dataForm" onsubmit="saveData(event)">
                        <div class="form-group">
                            <label for="itemType">é¡å‹ *</label>
                            <select id="itemType" class="form-input" required onchange="updateFormFields()">
                                <option value="">è«‹é¸æ“‡...</option>
                                <option value="root">ğŸ  åœ°é» (Root)</option>
                                <option value="node">ğŸ“¦ å®¹å™¨ (Node)</option>
                                <option value="leaf">ğŸ”– ç‰©ä»¶ (Leaf)</option>
                            </select>
                        </div>

                        <div class="form-group" id="parentField" style="display: none;">
                            <label for="parentId">çˆ¶ç´š *</label>
                            <select id="parentId" class="form-input">
                                <option value="">è«‹é¸æ“‡...</option>
                            </select>
                            <div class="form-hint">Node æˆ– Leaf éœ€è¦é¸æ“‡çˆ¶ç´š</div>
                        </div>

                        <div class="form-group" id="filterLocationField" style="display: none;">
                            <label for="filterLocationId">é™åˆ¶åœ°é»</label>
                            <select id="filterLocationId" class="form-input" onchange="updateFormFields()">
                                <option value="">æ‰€æœ‰åœ°é»</option>
                            </select>
                            <div class="form-hint">é¸æ“‡åœ°é»ä»¥ç¯©é¸å®¹å™¨é¸é …</div>
                        </div>

                        <div class="form-group">
                            <label for="itemName">åç¨± *</label>
                            <input type="text" id="itemName" class="form-input" placeholder="ä¾‹å¦‚: ç¡æˆ¿ã€è¡£æ«ƒã€ç¡è¡£" required>
                        </div>

                        <div class="form-group" id="quantityField" style="display: none;">
                            <label for="itemQuantity">æ•¸é‡</label>
                            <input type="number" id="itemQuantity" class="form-input" placeholder="1" min="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="description">æè¿°</label>
                            <textarea id="description" class="form-input form-textarea" rows="3" placeholder="é¸å¡«..."></textarea>
                        </div>

                        <div class="form-group">
                            <label>æ¨™ç±¤</label>
                            <div class="tags-input-wrapper" id="tagsWrapper">
                                <div class="tags-container" id="tagsContainer" onclick="document.getElementById('tagInput').focus()">
                                    <input type="text" id="tagInput" class="tag-input-field" placeholder="è¼¸å…¥æ¨™ç±¤..." autocomplete="off">
                                </div>
                                <div class="tags-suggestions" id="tagsSuggestions"></div>
                            </div>
                            <!-- éš±è—çš„åŸå§‹è¼¸å…¥æ¡†ï¼Œç”¨æ–¼å…¼å®¹èˆŠä»£ç¢¼å¼•ç”¨ï¼Œé›–ç„¶æˆ‘å€‘æœƒä¿®æ”¹é‚è¼¯ä¸ä½¿ç”¨å®ƒï¼Œä½†ä¿ç•™IDä»¥é˜²è¬ä¸€ -->
                            <input type="hidden" id="tags">
                        </div>
                        <input type="hidden" id="editId">
                        <input type="hidden" id="editType">
                    </form>

                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary btn-large" onclick="document.getElementById('dataForm').dispatchEvent(new Event('submit'))">
                            ğŸ’¾ ä¿å­˜é …ç›®
                        </button>
                        <button type="button" class="btn-reset" onclick="resetForm()" style="margin-left: 10px;">
                            ğŸ”„ é‡ç½®
                        </button>
                    </div>
                    </div>

                    <!-- å±¤ç´šæ§‹å»ºæ¨™ç±¤é  -->
                    <div id="hierarchyTabContent" class="tab-content">
                        <div class="hierarchy-builder">
                            <div id="hierarchyLevels" class="hierarchy-levels">
                                <!-- å±¤ç´šé¸æ“‡æ¡†å°‡åœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
                            </div>

                            <div class="hierarchy-actions">
                                <button class="btn btn-primary btn-large" onclick="saveHierarchy()">
                                    ğŸ’¾ ä¿å­˜çµæ§‹
                                </button>
                                <button type="button" class="btn-reset" onclick="resetHierarchy()" style="margin-left: 10px;">
                                    ğŸ”„ é‡ç½®
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <script>
        // æ•¸æ“šå­˜å„²
        const STORAGE_KEY = 'storageManagementData';
        let storageData = {
            roots: [],
            nodes: [],
            leafs: [],
            tempStorage: [] // ä¸´æ—¶å­˜å‚¨çš„å®¹å™¨å’Œç‰©ä»¶
        };
        let currentEditId = null;
        let currentEditType = null;
        let expandedLocations = new Set();
        let selectedLocationId = null;
        let expandedNodes = new Set();
        let selectedNodeId = null;

        // æœç´¢å„ªåŒ–è®Šé‡
        let searchTimeout;
        let searchResults = {
            matchingLeafIds: new Set(),
            matchingNodeIds: new Set(),
            nodesWithMatches: new Set(), // åŒ…å«åŒ¹é…é …çš„ç¯€é»
            rootsWithMatches: new Set()  // åŒ…å«åŒ¹é…é …çš„åœ°é»
        };
        let nodeMap = new Map(); // ID -> Node æ˜ å°„ï¼Œç”¨æ–¼å¿«é€ŸæŸ¥æ‰¾

        // å±¤ç´šæ§‹å»ºå™¨è®Šé‡
        let hierarchyLevels = [];
        let hierarchyLevelCounter = 0;

        // é é¢è¼‰å…¥åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            updateStats();
            renderLocations();
            renderTempStorage();
            initializeHierarchy();
            initTagInput(); // åˆå§‹åŒ–æ¨™ç±¤è¼¸å…¥ç³»çµ±

            // ä¸ºä¸´æ—¶å­˜å‚¨åŒºåŸŸæ·»åŠ æ‹–æ”¾äº‹ä»¶ç›‘å¬å™¨
            const tempStorageContent = document.getElementById('tempStorageList');
            if (tempStorageContent) {
                tempStorageContent.addEventListener('dragover', handleDragOver);
                tempStorageContent.addEventListener('drop', handleDropToTemp);
            }
        });

        // è¼‰å…¥æ•¸æ“š
        function loadData() {
            const savedData = localStorage.getItem(STORAGE_KEY);
            if (savedData) {
                storageData = JSON.parse(savedData);
                // ç¡®ä¿ tempStorage å­—æ®µå­˜åœ¨
                if (!storageData.tempStorage) {
                    storageData.tempStorage = [];
                }
            } else {
                // åˆå§‹åŒ–ç¤ºä¾‹æ•¸æ“š
                storageData = {
                    roots: [
                        { id: '1', name: 'ç¡æˆ¿', description: 'ä¸»è‡¥å®¤', tags: ['ç§äºº'], timestamp: new Date().toISOString() },
                        { id: '2', name: 'å®¢å»³', description: 'å…¬å…±å€åŸŸ', tags: [], timestamp: new Date().toISOString() },
                        { id: '3', name: 'å»šæˆ¿', description: 'çƒ¹é£ªå€', tags: [], timestamp: new Date().toISOString() },
                        { id: '4', name: 'æ›¸æˆ¿', description: 'å·¥ä½œå­¸ç¿’', tags: [], timestamp: new Date().toISOString() },
                        { id: '99', name: 'æœªåˆ†é¡', description: 'æš«å­˜', tags: [], timestamp: new Date().toISOString() }
                    ],
                    nodes: [
                        // ç¡æˆ¿
                        { id: '101', name: 'è¡£æ«ƒ', parentType: 'root', parentId: '1', description: 'ç™½è‰²å¤§è¡£æ«ƒ', tags: [], timestamp: new Date().toISOString() },
                        { id: '102', name: 'åºŠé ­æ«ƒ', parentType: 'root', parentId: '1', description: '', tags: [], timestamp: new Date().toISOString() },

                        // è¡£æ«ƒå…§éƒ¨
                        { id: '1011', name: 'ä¸Šå±¤æŠ½å±œ', parentType: 'node', parentId: '101', description: '', tags: [], timestamp: new Date().toISOString() },
                        { id: '1012', name: 'ä¸‹å±¤æŠ½å±œ', parentType: 'node', parentId: '101', description: '', tags: [], timestamp: new Date().toISOString() },

                        // å®¢å»³
                        { id: '201', name: 'é›»è¦–æ«ƒ', parentType: 'root', parentId: '2', description: '', tags: [], timestamp: new Date().toISOString() },
                        { id: '202', name: 'é‹æ«ƒ', parentType: 'root', parentId: '2', description: 'é–€å£', tags: [], timestamp: new Date().toISOString() },
                        { id: '203', name: 'é›œç‰©ç®±', parentType: 'root', parentId: '2', description: 'é€æ˜è† ç®±', tags: [], timestamp: new Date().toISOString() },

                        // å»šæˆ¿
                        { id: '301', name: 'å†°ç®±', parentType: 'root', parentId: '3', description: '', tags: [], timestamp: new Date().toISOString() },
                        { id: '302', name: 'æ«¥æ«ƒ', parentType: 'root', parentId: '3', description: 'ä¸Šæ–¹', tags: [], timestamp: new Date().toISOString() },

                        // æ›¸æˆ¿
                        { id: '401', name: 'æ›¸æ¶', parentType: 'root', parentId: '4', description: 'IKEAæ›¸æ¶', tags: [], timestamp: new Date().toISOString() },
                        { id: '402', name: 'æ›¸æ¡ŒæŠ½å±œ', parentType: 'root', parentId: '4', description: '', tags: [], timestamp: new Date().toISOString() },

                        // æœªåˆ†é¡
                        { id: '9901', name: 'å¾…æ•´ç†ç®±', parentType: 'root', parentId: '99', description: '', tags: [], timestamp: new Date().toISOString() }
                    ],
                    leafs: [
                        // ç¡æˆ¿ç‰©å“
                        { id: '1001', name: 'å†¬å­£ç¡è¡£', parentType: 'node', parentId: '1011', description: '', tags: ['è¡£ç‰©'], timestamp: new Date().toISOString() },
                        { id: '1002', name: 'å¤å­£Tæ¤', parentType: 'node', parentId: '1012', description: '', tags: ['è¡£ç‰©'], timestamp: new Date().toISOString() },
                        { id: '1003', name: 'å……é›»å™¨', parentType: 'node', parentId: '102', description: 'æ‰‹æ©Ÿå……é›»ç·š', tags: ['é›»å­'], timestamp: new Date().toISOString() },

                        // å®¢å»³ç‰©å“
                        { id: '2001', name: 'é™æ§å™¨', parentType: 'node', parentId: '201', description: 'é›»è¦–é™æ§', tags: [], timestamp: new Date().toISOString() },
                        { id: '2002', name: 'é‹å‹•é‹', parentType: 'node', parentId: '202', description: 'Nike', tags: ['é‹'], timestamp: new Date().toISOString() },
                        { id: '2003', name: 'æ‹–é‹', parentType: 'node', parentId: '202', description: '', tags: ['é‹'], timestamp: new Date().toISOString() },
                        { id: '2004', name: 'é›»æ± ', parentType: 'node', parentId: '203', description: 'AAé›»æ± ', tags: ['æ¶ˆè€—å“'], timestamp: new Date().toISOString() },

                        // å»šæˆ¿ç‰©å“
                        { id: '3001', name: 'ç‰›å¥¶', parentType: 'node', parentId: '301', description: '', tags: ['é£Ÿå“'], timestamp: new Date().toISOString() },
                        { id: '3002', name: 'é›è›‹', parentType: 'node', parentId: '301', description: '', tags: ['é£Ÿå“'], timestamp: new Date().toISOString() },
                        { id: '3003', name: 'æ³¡éºµ', parentType: 'node', parentId: '302', description: '', tags: ['é£Ÿå“'], timestamp: new Date().toISOString() },

                        // æ›¸æˆ¿ç‰©å“
                        { id: '4001', name: 'è­·ç…§', parentType: 'node', parentId: '402', description: 'é‡è¦è­‰ä»¶', tags: ['è­‰ä»¶'], timestamp: new Date().toISOString() },
                        { id: '4002', name: 'å‚™ç”¨é‘°åŒ™', parentType: 'node', parentId: '402', description: '', tags: ['é›œç‰©'], timestamp: new Date().toISOString() },
                        { id: '4003', name: 'å°èªª', parentType: 'node', parentId: '401', description: 'å“ˆåˆ©æ³¢ç‰¹', tags: ['æ›¸ç±'], timestamp: new Date().toISOString() },
                    ],
                    tempStorage: []
                };
                saveToStorage();
            }
        }

        // ä¿å­˜åˆ° LocalStorage
        function saveToStorage() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(storageData));
        }

        // --- æ¨™ç±¤ç®¡ç†ç³»çµ± ---
        let currentTags = [];

        function initTagInput() {
            const tagInput = document.getElementById('tagInput');
            const tagsSuggestions = document.getElementById('tagsSuggestions');

            if (!tagInput) return;

            // è¼¸å…¥äº‹ä»¶ï¼šé¡¯ç¤ºå»ºè­°
            tagInput.addEventListener('input', (e) => {
                const value = e.target.value.trim();
                if (value) {
                    showTagSuggestions(value);
                } else {
                    tagsSuggestions.classList.remove('show');
                }
            });

            // éµç›¤äº‹ä»¶ï¼šEnteræ·»åŠ ï¼ŒBackspaceåˆªé™¤
            tagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const value = tagInput.value.trim();
                    if (value) {
                        addTag(value);
                        tagInput.value = '';
                        tagsSuggestions.classList.remove('show');
                    }
                } else if (e.key === 'Backspace' && !tagInput.value) {
                    if (currentTags.length > 0) {
                        removeTag(currentTags[currentTags.length - 1]);
                    }
                }
            });

            // èšç„¦é¡¯ç¤ºå»ºè­°
            tagInput.addEventListener('focus', () => {
                const value = tagInput.value.trim();
                showTagSuggestions(value);
            });

            // é»æ“Šå¤–éƒ¨é—œé–‰å»ºè­°
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.tags-input-wrapper')) {
                    tagsSuggestions.classList.remove('show');
                }
            });
        }

        function getAllExistingTags() {
            const tags = new Set();
            const collect = (items) => {
                items.forEach(item => {
                    if (item.tags && Array.isArray(item.tags)) {
                        item.tags.forEach(t => tags.add(t));
                    }
                });
            };
            collect(storageData.roots);
            collect(storageData.nodes);
            collect(storageData.leafs);
            collect(storageData.tempStorage);
            return Array.from(tags).sort();
        }

        function showTagSuggestions(filterText = '') {
            const tagsSuggestions = document.getElementById('tagsSuggestions');
            const existingTags = getAllExistingTags();
            const filteredTags = existingTags.filter(t =>
                t.toLowerCase().includes(filterText.toLowerCase()) &&
                !currentTags.includes(t)
            );

            let html = '';

            // å¦‚æœè¼¸å…¥äº†æ–‡å­—ï¼Œä¸”è©²æ–‡å­—ä¸åœ¨ç¾æœ‰æ¨™ç±¤ä¸­ï¼Œé¡¯ç¤º"å‰µå»ºæ–°æ¨™ç±¤"é¸é …
            if (filterText && !existingTags.includes(filterText) && !currentTags.includes(filterText)) {
                html += `
                    <div class="suggestion-item" onclick="addTag('${filterText}'); document.getElementById('tagInput').value = ''; document.getElementById('tagsSuggestions').classList.remove('show');">
                        <span>${filterText}</span>
                        <span class="new-tag-badge">å‰µå»ºæ–°æ¨™ç±¤</span>
                    </div>
                `;
            }

            // é¡¯ç¤ºç¾æœ‰æ¨™ç±¤å»ºè­°
            filteredTags.forEach(tag => {
                // è¨ˆç®—è©²æ¨™ç±¤çš„ä½¿ç”¨æ¬¡æ•¸
                let count = 0;
                const countIn = (items) => items.forEach(i => { if(i.tags && i.tags.includes(tag)) count++; });
                countIn(storageData.roots);
                countIn(storageData.nodes);
                countIn(storageData.leafs);
                countIn(storageData.tempStorage);

                html += `
                    <div class="suggestion-item" onclick="addTag('${tag}'); document.getElementById('tagInput').value = ''; document.getElementById('tagsSuggestions').classList.remove('show');">
                        <span>${tag}</span>
                        <span class="count-badge">${count}</span>
                    </div>
                `;
            });

            if (html) {
                tagsSuggestions.innerHTML = html;
                tagsSuggestions.classList.add('show');
            } else {
                tagsSuggestions.classList.remove('show');
            }
        }

        function addTag(tag) {
            tag = tag.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                renderTags();
            }
        }

        function removeTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            renderTags();
        }

        function renderTags() {
            const container = document.getElementById('tagsContainer');
            const input = document.getElementById('tagInput');

            // ç§»é™¤ç¾æœ‰çš„ chips (ä¿ç•™ input)
            const chips = container.querySelectorAll('.tag-chip');
            chips.forEach(chip => chip.remove());

            // æ’å…¥æ–°çš„ chips
            currentTags.forEach(tag => {
                const chip = document.createElement('div');
                chip.className = 'tag-chip';
                chip.innerHTML = `
                    ${tag}
                    <span class="tag-remove" onclick="removeTag('${tag}')">Ã—</span>
                `;
                container.insertBefore(chip, input);
            });

            // æ›´æ–°éš±è—çš„ input å€¼ (ç‚ºäº†å…¼å®¹æ€§)
            document.getElementById('tags').value = currentTags.join(', ');
        }

        // æ›´æ–°çµ±è¨ˆ
        function updateStats() {
            // æ›´æ–°å·¦å´ stats-barï¼ˆéš±è—ï¼‰
            document.getElementById('totalRoots').textContent = storageData.roots.length;
            document.getElementById('totalNodes').textContent = storageData.nodes.length;
            document.getElementById('totalLeafs').textContent = storageData.leafs.length;

            // æ›´æ–° header ä¸­çš„çµ±è¨ˆä¿¡æ¯
            document.getElementById('headerTotalRoots').textContent = storageData.roots.length;
            document.getElementById('headerTotalNodes').textContent = storageData.nodes.length;
            document.getElementById('headerTotalLeafs').textContent = storageData.leafs.length;
        }

        // ç²å–æ’åºå¾Œçš„å…„å¼Ÿé …ç›®ï¼ˆç”¨æ–¼è¨ˆç®—æ’å…¥ä½ç½®ï¼‰
        function getSortedSiblings(parentType, parentId, excludeId = null) {
            const nodes = storageData.nodes.filter(n => n.parentType === parentType && n.parentId === parentId && n.id !== excludeId);
            const leafs = storageData.leafs.filter(l => l.parentType === parentType && l.parentId === parentId && l.id !== excludeId);

            const items = [
                ...nodes.map(n => ({ type: 'node', data: n })),
                ...leafs.map(l => ({ type: 'leaf', data: l }))
            ];

            items.sort((a, b) => new Date(a.data.timestamp) - new Date(b.data.timestamp));
            return items;
        }

        // æ¸²æŸ“æ··åˆé …ç›®ï¼ˆå®¹å™¨å’Œç‰©ä»¶ï¼‰ï¼ŒæŒ‰æ™‚é–“æ’åº
        function renderMixedItems(nodes, leafs, level = 0, parentId = null, searchText = '') {
            // æœç´¢æ™‚ä¿ç•™æ‰€æœ‰ç‰©å“å’Œå®¹å™¨ï¼Œä¸é€²ä¸€æ­¥éæ¿¾
            let filteredNodes = nodes;
            let filteredLeafs = leafs;

            const items = [
                ...filteredNodes.map(n => ({ type: 'node', data: n })),
                ...filteredLeafs.map(l => ({ type: 'leaf', data: l }))
            ];

            // å®¹å™¨å„ªå…ˆï¼Œç„¶å¾ŒæŒ‰æ™‚é–“æˆ³æ’åº
            items.sort((a, b) => {
                // å¦‚æœæœ‰é¸ä¸­çš„ç¯€é»ï¼Œå°‡å…¶ç½®é ‚
                if (selectedNodeId) {
                    if (a.type === 'node' && a.data.id === selectedNodeId) return -1;
                    if (b.type === 'node' && b.data.id === selectedNodeId) return 1;
                }

                if (a.type !== b.type) {
                    return a.type === 'node' ? -1 : 1;
                }
                return new Date(a.data.timestamp) - new Date(b.data.timestamp);
            });

            return items.map(item => {
                if (item.type === 'node') {
                    return renderNodeCard(item.data, level, parentId, searchText);
                } else {
                    return renderLeafCard(item.data, searchText);
                }
            }).join('');
        }



        // æ¸²æŸ“åœ°é»åˆ—è¡¨
        function renderLocations(searchText = '') {
            const container = document.getElementById('locationsList');
            let roots = storageData.roots;

            // æœç´¢éæ¿¾ - ä½¿ç”¨é è¨ˆç®—çµæœ
            if (searchText) {
                performSearch(searchText);

                // æ‰¾åˆ°åŒ…å«åŒ¹é…ç‰©ä»¶æˆ–å®¹å™¨çš„æ‰€æœ‰åœ°é»
                roots = roots.filter(root => {
                    // æª¢æŸ¥åœ°é»æœ¬èº«æ˜¯å¦åŒ¹é…
                    const isRootMatch = root.name.toLowerCase().includes(searchText.toLowerCase()) ||
                        (root.description && root.description.toLowerCase().includes(searchText.toLowerCase()));

                    // æª¢æŸ¥åœ°é»ä¸‹æ˜¯å¦æœ‰åŒ¹é…çš„ç‰©ä»¶æˆ–å®¹å™¨
                    const hasMatches = searchResults.rootsWithMatches.has(root.id);

                    return isRootMatch || hasMatches;
                });
            }

            if (roots.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #a0aec0;">
                        <p>æš«ç„¡åœ°é»</p>
                        <p style="font-size: 12px; margin-top: 10px;">é»æ“Šä¸Šæ–¹ "+ æ–°å¢åœ°é»" é–‹å§‹ä½¿ç”¨</p>
                    </div>
                `;
                return;
            }

            let selectedRoot = null;
            let selectedIndex = -1;

            // å¦‚æœæœ‰é¸ä¸­çš„åœ°é»ï¼Œå°‡å…¶ç§»åˆ°ç¬¬ä¸€ä½ (åƒ…åœ¨éæœç´¢æ¨¡å¼ä¸‹)
            let sortedRoots = [...roots];
            if (selectedLocationId && !searchText) {
                const selectedRootIndex = sortedRoots.findIndex(r => r.id === selectedLocationId);
                if (selectedRootIndex > -1) {
                    const selectedRootItem = sortedRoots.splice(selectedRootIndex, 1)[0];
                    sortedRoots.unshift(selectedRootItem);
                }
            }

            const locationCards = [];

            sortedRoots.forEach((root) => {
                const itemCount = countRootItems(root.id);
                const isSelected = selectedLocationId === root.id;
                const isExpanded = isSelected || (searchText && searchText.trim() !== '');

                locationCards.push(`
                    <div class="location-grid-item ${isSelected ? 'selected' : ''}"
                         onclick="selectLocation('${root.id}')"
                         onmouseenter="showHoverPopup(event, 'root', '${root.id}')"
                         onmouseleave="hideHoverPopup()"
                         ondragover="handleDragOver(event)"
                         ondrop="handleDrop(event, 'root', '${root.id}')">
                        <div class="location-icon">ğŸ </div>
                        <div class="location-name">${root.name}</div>
                        <div class="location-count">${itemCount} é …</div>
                        <div class="location-actions">
                            <button class="btn-mini" onclick="editItem('root', '${root.id}'); event.stopPropagation(); return false;" title="ç·¨è¼¯">âœï¸</button>
                            <button class="btn-mini" onclick="deleteItem('root', '${root.id}'); event.stopPropagation(); return false;" title="åˆªé™¤">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                `);

                if (isExpanded) {
                    let directNodes = storageData.nodes.filter(n => n.parentType === 'root' && n.parentId === root.id);
                    let directLeafs = storageData.leafs.filter(l => l.parentType === 'root' && l.parentId === root.id);

                    // å¦‚æœæœ‰æœç´¢æ–‡æœ¬ï¼Œéæ¿¾é¡¯ç¤ºåŒ¹é…çš„é …ç›®
                    let displayNodes = directNodes;
                    let displayLeafs = directLeafs;

                    const detailPanel = `
                        <div class="location-detail-expanded"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event, 'root', '${root.id}')">
                            <div class="detail-header-inline">
                                <h4>ğŸ  ${root.name} (${displayNodes.length + displayLeafs.length})</h4>
                                <div class="detail-actions-inline">
                                    <button class="btn-action-small" onclick="editItem('root', '${root.id}'); event.stopPropagation(); return false;">âœï¸ ç·¨è¼¯</button>
                                    <button class="btn-action-small danger" onclick="deleteItem('root', '${root.id}'); event.stopPropagation(); return false;">ğŸ—‘ï¸ åˆªé™¤</button>
                                    <button class="btn-action-small" onclick="closeDetail(); event.stopPropagation(); return false;">âœ• é—œé–‰</button>
                                </div>
                            </div>
                            <div class="nodes-grid-inline">
                                ${renderMixedItems(displayNodes, displayLeafs, 0, root.id, searchText)}
                                ${displayNodes.length === 0 && displayLeafs.length === 0 ? '<p class="empty-message">æš‚ç„¡å®¹å™¨æˆ–ç‰©ä»¶</p>' : ''}
                            </div>
                            <div class="add-section-inline">
                                <button class="btn-add-item" onclick="addItemToLocation('${root.id}'); event.stopPropagation();">+ æ·»åŠ å®¹å™¨/ç‰©ä»¶</button>
                            </div>
                        </div>
                    `;
                    locationCards.push(detailPanel);
                }
            });

            container.innerHTML = locationCards.join('');
        }

        // è¨ˆç®—åœ°é»ä¸‹çš„é …ç›®æ•¸é‡
        function countRootItems(rootId) {
            const directNodes = storageData.nodes.filter(n => n.parentType === 'root' && n.parentId === rootId);
            const directLeafs = storageData.leafs.filter(l => l.parentType === 'root' && l.parentId === rootId);
            let count = directNodes.length + directLeafs.length;

            directNodes.forEach(node => {
                count += countNodeItems(node.id);
            });

            return count;
        }

        // è¨ˆç®—ç¯€é»ä¸‹çš„é …ç›®æ•¸é‡
        function countNodeItems(nodeId) {
            const childNodes = storageData.nodes.filter(n => n.parentType === 'node' && n.parentId === nodeId);
            const childLeafs = storageData.leafs.filter(l => l.parentType === 'node' && l.parentId === nodeId);
            let count = childNodes.length + childLeafs.length;

            childNodes.forEach(node => {
                count += countNodeItems(node.id);
            });

            return count;
        }

        // æ¸²æŸ“åœ°é»å…§å®¹
        function renderLocationContent(root) {
            const directNodes = storageData.nodes.filter(n => n.parentType === 'root' && n.parentId === root.id);

            return `
                <div class="location-content">
                    <div class="detail-header">
                        <h4>ğŸ“¦ å®¹å™¨èˆ‡ç‰©ä»¶</h4>
                        <div class="detail-actions">
                            <button class="btn-action-small" onclick="editItem('root', '${root.id}'); event.stopPropagation(); return false;">âœï¸ ç·¨è¼¯åœ°é»</button>
                            <button class="btn-action-small danger" onclick="deleteItem('root', '${root.id}'); event.stopPropagation(); return false;">ğŸ—‘ï¸ åˆªé™¤</button>
                        </div>
                    </div>
                    <div class="container-list">
                        ${directNodes.length > 0 ? directNodes.map(node => renderNodeItem(node)).join('') : '<p style="color: #a0aec0; font-size: 13px; padding: 10px 0;">æš«ç„¡å®¹å™¨æˆ–ç‰©ä»¶</p>'}
                    </div>
                    <div class="add-section">
                        <button class="btn-add-item" onclick="addItemToLocation('${root.id}'); event.stopPropagation();">+ æ·»åŠ å®¹å™¨/ç‰©ä»¶</button>
                    </div>
                </div>
            `;
        }

        // æ¸²æŸ“ç¯€é»é …ç›®
        function renderNodeItem(node, level = 0) {
            const childNodes = storageData.nodes.filter(n => n.parentType === 'node' && n.parentId === node.id);
            const childLeafs = storageData.leafs.filter(l => l.parentType === 'node' && l.parentId === node.id);

            return `
                <div class="container-item" style="margin-left: ${level * 20}px;">
                    <div class="container-row">
                        <span class="container-icon">ğŸ“¦</span>
                        <span class="container-name">${node.name}</span>
                        <span class="item-count">${childNodes.length + childLeafs.length} é …</span>
                        <div class="item-actions">
                            <button class="btn-mini" onclick="editItem('node', '${node.id}'); event.stopPropagation(); return false;">âœï¸</button>
                            <button class="btn-mini" onclick="deleteItem('node', '${node.id}'); event.stopPropagation(); return false;">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    ${childLeafs.length > 0 || childNodes.length > 0 ? `
                        <div class="items-list">
                            ${childLeafs.map(leaf => `
                                <div class="item-row">
                                    <span class="item-icon">ğŸ”–</span>
                                    <span class="item-name">${leaf.name}</span>
                                    <div class="item-actions">
                                        <button class="btn-mini" onclick="editItem('leaf', '${leaf.id}'); event.stopPropagation(); return false;">âœï¸</button>
                                        <button class="btn-mini" onclick="deleteItem('leaf', '${leaf.id}'); event.stopPropagation(); return false;">ğŸ—‘ï¸</button>
                                    </div>
                                </div>
                            `).join('')}
                            ${childNodes.map(childNode => renderNodeItem(childNode, level + 1)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // é¸æ“‡åœ°é»
        function selectLocation(rootId) {
            const searchText = document.getElementById('searchInput').value;
            if (selectedLocationId === rootId) {
                // å¦‚æœé»æ“ŠåŒä¸€å€‹åœ°é»,å‰‡é—œé–‰è©³æƒ…
                selectedLocationId = null;
            } else {
                selectedLocationId = rootId;
            }
            renderLocations(searchText);
        }

        // é—œé–‰è©³æƒ…é¢æ¿
        function closeDetail() {
            const searchText = document.getElementById('searchInput').value;
            selectedLocationId = null;
            renderLocations(searchText);
        }

        // æ¸²æŸ“ç‰©ä»¶å¡ç‰‡
        function renderLeafCard(leaf, searchText = '') {
            const quantity = leaf.quantity || 1;

            // æª¢æŸ¥æ˜¯å¦åŒ¹é…æœç´¢æ–‡æœ¬
            let isHighlighted = false;
            if (searchText) {
                const searchLower = searchText.toLowerCase();
                isHighlighted = leaf.name.toLowerCase().includes(searchLower) ||
                               (leaf.description && leaf.description.toLowerCase().includes(searchLower));
            }

            const highlightStyle = isHighlighted ? 'background-color: #fef3c7; border: 2px solid #fbbf24;' : '';

            return `
                <div class="leaf-card"
                     style="${highlightStyle}"
                     draggable="true"
                     onmouseenter="showHoverPopup(event, 'leaf', '${leaf.id}')"
                     onmouseleave="hideHoverPopup()"
                     ondragstart="handleDragStart(event, 'leaf', '${leaf.id}')"
                     ondragover="handleDragOver(event)"
                     ondrop="handleDrop(event, 'leaf', '${leaf.id}')">
                    <div class="leaf-icon">ğŸ”–</div>
                    <div class="leaf-content">
                        <div class="leaf-name">${leaf.name}</div>
                        <div class="leaf-count">${quantity} å€‹</div>
                    </div>
                    <div class="leaf-actions">
                        <button class="btn-mini" onclick="editItem('leaf', '${leaf.id}'); event.stopPropagation(); return false;">âœï¸</button>
                        <button class="btn-mini" onclick="deleteItem('leaf', '${leaf.id}'); event.stopPropagation(); return false;">ğŸ—‘ï¸</button>
                    </div>
                </div>
            `;
        }



        // æ¸²æŸ“ç¯€é»å¡ç‰‡
        function renderNodeCard(node, level = 0, parentId = null, searchText = '') {
            let childNodes = storageData.nodes.filter(n => n.parentType === 'node' && n.parentId === node.id);
            const childLeafs = storageData.leafs.filter(l => l.parentType === 'node' && l.parentId === node.id);

            // å¦‚æœæœç´¢ï¼Œè‡ªå‹•å±•é–‹åŒ…å«åŒ¹é…é …ç›®çš„ç¯€é»
            let isExpanded = expandedNodes.has(node.id);
            if (searchText) {
                // ä½¿ç”¨é è¨ˆç®—çš„çµæœï¼šå¦‚æœè©²ç¯€é»åŒ…å«åŒ¹é…é …ï¼ˆæ˜¯åŒ¹é…é …çš„ç¥–å…ˆï¼‰ï¼Œå‰‡å±•é–‹
                const hasMatchingChildren = searchResults.nodesWithMatches.has(node.id);
                isExpanded = hasMatchingChildren || isExpanded;
            }

            const itemCount = childNodes.length + childLeafs.length;
            const hasChildren = childNodes.length > 0 || childLeafs.length > 0;
            const isSelected = selectedNodeId === node.id;

            // æª¢æŸ¥æ˜¯å¦ç‚ºé¸ä¸­ç¯€é»çš„ç¥–å…ˆ
            const isAncestorOfSelected = selectedNodeId && isAncestorOf(node.id, selectedNodeId);
            const shouldBeFullWidth = isSelected || isAncestorOfSelected || (isExpanded && hasChildren);

            let html = `
                <div class="node-card ${isSelected ? 'selected-node' : ''} ${isAncestorOfSelected ? 'ancestor-node' : ''}"
                     style="${shouldBeFullWidth ? 'grid-column: 1 / -1;' : ''}"
                     ${!isExpanded ? 'draggable="true"' : ''}
                     ${!isExpanded ? `ondragstart="handleNodeDragStart(event, '${node.id}', ${isExpanded})"` : ''}
                     onmouseenter="showHoverPopup(event, 'node', '${node.id}')"
                     onmouseleave="hideHoverPopup()"
                     ondragover="handleDragOver(event)"
                     ondrop="handleDrop(event, 'node', '${node.id}')">
                    <div class="node-card-header"
                         ${isExpanded ? 'draggable="true"' : ''}
                         ${isExpanded ? `ondragstart="handleNodeDragStart(event, '${node.id}', ${isExpanded})"` : ''}>
                        <div class="node-header-content"
                             style="display: flex; flex-direction: column; align-items: center; width: 100%; cursor: pointer;"
                             onclick="selectNode('${node.id}', '${parentId || 'root'}'); event.stopPropagation();">
                            ${hasChildren ? `
                                <button class="node-toggle" onclick="toggleNode('${node.id}'); event.stopPropagation();">
                                    ${isExpanded ? 'â–¼' : 'â–¶'}
                                </button>
                            ` : '<span class="node-spacer"></span>'}
                            <div class="node-icon">ğŸ“¦</div>
                            <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                                <div class="node-name" style="width: auto;">${node.name}</div>
                                <div class="node-count">${itemCount} é …</div>
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="btn-mini" onclick="editItem('node', '${node.id}'); event.stopPropagation(); return false;">âœï¸</button>
                            <button class="btn-mini" onclick="deleteItem('node', '${node.id}'); event.stopPropagation(); return false;">ğŸ—‘ï¸</button>
                        </div>
                    </div>
            `;

            // å¦‚æœå±•é–‹ä¸”æœ‰å­é …ç›®ï¼Œé¡¯ç¤ºåµŒå¥—å…§å®¹
            if (isExpanded && hasChildren) {
                html += `
                    <div class="node-children">
                        <div class="node-children-grid"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event, 'node', '${node.id}')">
                            ${renderMixedItems(childNodes, childLeafs, level + 1, node.id, searchText)}
                            <div class="leaf-card add-item-card" onclick="addItemToNode('${node.id}'); event.stopPropagation();">
                                <div class="add-icon">+</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (isExpanded && !hasChildren) {
                // å¦‚æœå±•é–‹ä½†æ²’æœ‰å­é …ç›®ï¼Œåªé¡¯ç¤ºæ·»åŠ æŒ‰éˆ•
                html += `
                    <div class="node-children">
                        <div class="node-children-grid">
                            <div class="leaf-card add-item-card" onclick="addItemToNode('${node.id}'); event.stopPropagation();">
                                <div class="add-icon">+</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `</div>`;
            return html;
        }

        // é¸æ“‡ç¯€é»
        function selectNode(nodeId, parentId) {
            const searchText = document.getElementById('searchInput').value;
            // å¦‚æœé»æ“ŠåŒä¸€å€‹ç¯€é», å–æ¶ˆé¸ä¸­ä¸¦æ”¶èµ·
            if (selectedNodeId === nodeId) {
                selectedNodeId = null;
                if (expandedNodes.has(nodeId)) {
                    expandedNodes.delete(nodeId);
                }
                renderLocations(searchText);
                return;
            }

            selectedNodeId = nodeId;

            // æ”¶èµ·æ‰€æœ‰å…¶ä»–ç¯€é»ï¼Œä¿ç•™ç•¶å‰ç¯€é»åŠå…¶ç¥–å…ˆéˆ
            const ancestorIds = getAncestorIds(nodeId);
            const nodesToKeep = new Set([nodeId, ...ancestorIds]);

            // åªä¿ç•™ç•¶å‰ç¯€é»åŠå…¶ç¥–å…ˆçš„å±•é–‹ç‹€æ…‹
            const newExpandedNodes = new Set();
            expandedNodes.forEach(id => {
                if (nodesToKeep.has(id)) {
                    newExpandedNodes.add(id);
                }
            });
            expandedNodes = newExpandedNodes;

            // è‡ªå‹•å±•é–‹è©²ç¯€é»
            if (!expandedNodes.has(nodeId)) {
                expandedNodes.add(nodeId);
            }

            renderLocations(searchText);
        }

        // ç²å–ç¯€é»çš„æ‰€æœ‰ç¥–å…ˆID (é˜²æ­¢ç„¡é™å¾ªç’°)
        function getAncestorIds(nodeId) {
            const ancestors = [];
            let currentNode = storageData.nodes.find(n => n.id === nodeId);
            const visited = new Set(); // é˜²æ­¢æ•¸æ“šå·²æå£æ™‚çš„ç„¡é™å¾ªç’°

            while (currentNode && currentNode.parentType === 'node') {
                if (visited.has(currentNode.id)) break;
                visited.add(currentNode.id);

                ancestors.push(currentNode.parentId);
                currentNode = storageData.nodes.find(n => n.id === currentNode.parentId);
            }

            return ancestors;
        }

        // æª¢æŸ¥nodeIdæ˜¯å¦ç‚ºtargetIdçš„ç¥–å…ˆ
        function isAncestorOf(nodeId, targetId) {
            const ancestors = getAncestorIds(targetId);
            return ancestors.includes(nodeId);
        }

        // åˆ‡æ›ç¯€é»å±•é–‹/æŠ˜ç–Š
        function toggleNode(nodeId) {
            if (expandedNodes.has(nodeId)) {
                expandedNodes.delete(nodeId);
            } else {
                expandedNodes.add(nodeId);
            }
            const searchText = document.getElementById('searchInput').value;
            renderLocations(searchText);
            renderTempStorage();
        }

        // æ–°å¢åœ°é»
        function addNewLocation() {
            resetForm();
            document.getElementById('itemType').value = 'root';
            updateFormFields();
            document.getElementById('itemName').focus();
        }

        // æ·»åŠ é …ç›®åˆ°åœ°é»
        function addItemToLocation(rootId) {
            resetForm();
            document.getElementById('itemType').value = 'node';
            updateFormFields();
            document.getElementById('parentId').value = `root-${rootId}`;
            document.getElementById('itemName').focus();
            switchTab('form');
        }

        // æ·»åŠ é …ç›®åˆ°ç¯€é»
        function addItemToNode(nodeId) {
            resetForm();
            document.getElementById('itemType').value = 'node';
            updateFormFields();
            document.getElementById('parentId').value = `node-${nodeId}`;
            document.getElementById('itemName').focus();
            switchTab('form');
        }

        // æ›´æ–°è¡¨å–®æ¬„ä½
        function updateFormFields() {
            const itemType = document.getElementById('itemType').value;
            const editType = document.getElementById('editType').value;
            const parentField = document.getElementById('parentField');
            const parentSelect = document.getElementById('parentId');
            const quantityField = document.getElementById('quantityField');
            const filterLocationField = document.getElementById('filterLocationField');

            // å¦‚æœæ˜¯ä¸´æ—¶å­˜å‚¨é¡¹ç›®ï¼Œä¸éœ€è¦çˆ¶çº§é€‰æ‹©
            if (editType === 'temp') {
                parentField.style.display = 'none';
                parentSelect.required = false;
                filterLocationField.style.display = 'none';

                // è‡¨æ™‚å­˜å„²å¦‚æœæ˜¯ leaf é¡å‹ä¹Ÿé¡¯ç¤ºæ•¸é‡
                if (itemType === 'leaf') {
                    quantityField.style.display = 'block';
                } else {
                    quantityField.style.display = 'none';
                }
                return;
            }

            if (itemType === 'root') {
                parentField.style.display = 'none';
                parentSelect.required = false;
                quantityField.style.display = 'none';
                filterLocationField.style.display = 'none';
            } else if (itemType === 'node') {
                parentField.style.display = 'block';
                parentSelect.required = true;
                quantityField.style.display = 'none';
                filterLocationField.style.display = 'block';
                populateFilterLocations();
                populateParentOptions(itemType);
            } else if (itemType === 'leaf') {
                parentField.style.display = 'block';
                parentSelect.required = true;
                quantityField.style.display = 'block';
                filterLocationField.style.display = 'none';
                populateParentOptions(itemType);
            }
        }

        // å¡«å……åœ°é»ç¯©é¸é¸é …
        function populateFilterLocations() {
            const filterSelect = document.getElementById('filterLocationId');
            const currentValue = filterSelect.value;
            filterSelect.innerHTML = '<option value="">æ‰€æœ‰åœ°é»</option>';

            storageData.roots.forEach(root => {
                filterSelect.innerHTML += `<option value="root-${root.id}">ğŸ  ${root.name}</option>`;
            });

            // æ¢å¾©ä¹‹å‰çš„é¸æ“‡
            if (currentValue) {
                filterSelect.value = currentValue;
            }
        }

        // å¡«å……çˆ¶ç´šé¸é …
        function populateParentOptions(childType) {
            const parentSelect = document.getElementById('parentId');
            const currentValue = parentSelect.value;
            const filterLocationId = document.getElementById('filterLocationId')?.value || '';
            parentSelect.innerHTML = '<option value="">è«‹é¸æ“‡...</option>';

            if (childType === 'node') {
                // Node å¯ä»¥åœ¨ Root æˆ–å…¶ä»– Node ä¸‹
                // å¦‚æœé¸æ“‡äº†åœ°é»ç¯©é¸ï¼Œåªé¡¯ç¤ºè©²åœ°é»å’Œå…¶å®¹å™¨
                if (filterLocationId) {
                    const [filterType, filterId] = filterLocationId.split('-');
                    if (filterType === 'root') {
                        const root = storageData.roots.find(r => r.id === filterId);
                        if (root) {
                            parentSelect.innerHTML += `<option value="root-${root.id}">ğŸ  ${root.name}</option>`;
                        }
                        // åªé¡¯ç¤ºè©²åœ°é»ä¸‹çš„å®¹å™¨
                        storageData.nodes.forEach(node => {
                            if (node.parentType === 'root' && node.parentId === filterId) {
                                const path = getItemPath('node', node.id);
                                parentSelect.innerHTML += `<option value="node-${node.id}">ğŸ“¦ ${path}</option>`;
                            }
                        });
                    }
                } else {
                    // é¡¯ç¤ºæ‰€æœ‰åœ°é»å’Œå®¹å™¨
                    storageData.roots.forEach(root => {
                        parentSelect.innerHTML += `<option value="root-${root.id}">ğŸ  ${root.name}</option>`;
                    });
                    storageData.nodes.forEach(node => {
                        const path = getItemPath('node', node.id);
                        parentSelect.innerHTML += `<option value="node-${node.id}">ğŸ“¦ ${path}</option>`;
                    });
                }

                // å¦‚æœæ²’æœ‰ç•¶å‰é¸æ“‡å€¼ï¼Œé»˜èªé¸æ“‡"æœªåˆ†é¡"ä½œç‚ºçˆ¶ç´š
                if (!currentValue) {
                    const unclassifiedRoot = storageData.roots.find(r => r.name === 'æœªåˆ†é¡');
                    if (unclassifiedRoot) {
                        parentSelect.value = `root-${unclassifiedRoot.id}`;
                    }
                } else {
                    parentSelect.value = currentValue;
                }
            } else if (childType === 'leaf') {
                // Leaf å¯ä»¥åœ¨ Root æˆ– Node ä¸‹
                storageData.roots.forEach(root => {
                    parentSelect.innerHTML += `<option value="root-${root.id}">ğŸ  ${root.name}</option>`;
                });
                storageData.nodes.forEach(node => {
                    const path = getItemPath('node', node.id);
                    parentSelect.innerHTML += `<option value="node-${node.id}">ğŸ“¦ ${path}</option>`;
                });

                // æ¢å¾©ä¹‹å‰çš„é¸æ“‡
                if (currentValue) {
                    parentSelect.value = currentValue;
                }
            }
        }

        // ç²å–é …ç›®è·¯å¾‘
        function getItemPath(type, id) {
            let path = [];
            let currentType = type;
            let currentId = id;

            while (currentId) {
                let item;
                if (currentType === 'root') {
                    item = storageData.roots.find(r => r.id === currentId);
                    if (item) {
                        path.unshift(item.name);
                        break;
                    }
                } else if (currentType === 'node') {
                    item = storageData.nodes.find(n => n.id === currentId);
                    if (item) {
                        path.unshift(item.name);
                        if (item.parentType && item.parentId) {
                            currentType = item.parentType;
                            currentId = item.parentId;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }

            return path.join(' â†’ ');
        }

        // ç²å–ç”¨æ–¼æ—¥èªŒçš„å®Œæ•´è·¯å¾‘
        function getLogPath(type, id) {
            if (type === 'temp') return 'è‡¨æ™‚å­˜å„²';

            let item;
            if (type === 'root') item = storageData.roots.find(i => i.id === id);
            else if (type === 'node') item = storageData.nodes.find(i => i.id === id);
            else if (type === 'leaf') item = storageData.leafs.find(i => i.id === id);

            if (!item) return 'æœªçŸ¥';

            if (type === 'root') return item.name;

            if (type === 'node') {
                return getItemPath('node', id);
            }

            if (type === 'leaf') {
                const parentPath = getItemPath(item.parentType, item.parentId);
                return `${parentPath} . ${item.name}`;
            }

            return item.name;
        }

        // ä¿å­˜æ•¸æ“š
        function saveData(event) {
            event.preventDefault();

            const itemType = document.getElementById('itemType').value;
            const itemName = document.getElementById('itemName').value.trim();
            const itemQuantity = document.getElementById('itemQuantity').value;
            const description = document.getElementById('description').value.trim();
            // ä½¿ç”¨æ–°çš„æ¨™ç±¤ç³»çµ±
            const tags = [...currentTags];
            const editId = document.getElementById('editId').value;
            const editType = document.getElementById('editType').value;

            if (!itemName) {
                alert('è«‹è¼¸å…¥åç¨±');
                return;
            }

            const data = {
                id: editId || Date.now().toString(),
                name: itemName,
                description: description,
                tags: tags,
                timestamp: new Date().toISOString()
            };

            if (itemType === 'leaf') {
                data.quantity = itemQuantity ? parseInt(itemQuantity) : 1;
            }

            // å¦‚æœæ˜¯ä¸´æ—¶å­˜å‚¨
            if (editType === 'temp') {
                if (itemType !== 'node' && itemType !== 'leaf') {
                    alert('è‡¨æ™‚å­˜å„²åªèƒ½æ·»åŠ å®¹å™¨æˆ–ç‰©ä»¶');
                    return;
                }

                data.type = itemType;

                if (editId) {
                    // æ›´æ–°ä¸´æ—¶é¡¹ç›®
                    const index = storageData.tempStorage.findIndex(item => item.id === editId);
                    if (index !== -1) {
                        storageData.tempStorage[index] = data;
                    }
                    showNotification('æ›´æ–°æˆåŠŸï¼', 'success');
                } else {
                    // æ–°å¢ä¸´æ—¶é¡¹ç›®
                    storageData.tempStorage.push(data);
                    showNotification('å·²æ·»åŠ åˆ°è‡¨æ™‚å­˜å„²ï¼', 'success');
                }

                saveToStorage();
                resetForm();
                renderTempStorage();
                return;
            }

            // è™•ç†çˆ¶ç´šé—œä¿‚
            if (itemType === 'node' || itemType === 'leaf') {
                const parentValue = document.getElementById('parentId').value;
                if (!parentValue) {
                    alert(`${itemType === 'node' ? 'å®¹å™¨' : 'ç‰©ä»¶'}å¿…é ˆé¸æ“‡çˆ¶ç´šï¼`);
                    return;
                }
                const [parentType, parentId] = parentValue.split('-');
                data.parentType = parentType;
                data.parentId = parentId;
            }

            // è™•ç†å®¹å™¨çš„é™åˆ¶åœ°é»
            if (itemType === 'node') {
                const filterLocationId = document.getElementById('filterLocationId')?.value || '';
                if (filterLocationId) {
                    // å¦‚æœé¸æ“‡äº†é™åˆ¶åœ°é»ï¼Œå°‡å…¶ä¿å­˜åˆ°å®¹å™¨
                    const [, rootId] = filterLocationId.split('-');
                    data.restrictedRootId = rootId;
                } else {
                    // å¦‚æœæ²’æœ‰é¸æ“‡é™åˆ¶åœ°é»ï¼Œæ¸…é™¤è©²å­—æ®µ
                    delete data.restrictedRootId;
                }
            }

            // ç·¨è¼¯æˆ–æ–°å¢
            if (editId && editType) {
                updateItem(editType, data);
                showNotification('æ›´æ–°æˆåŠŸï¼', 'success');
            } else {
                if (itemType === 'root') {
                    storageData.roots.push(data);
                } else if (itemType === 'node') {
                    storageData.nodes.push(data);
                } else if (itemType === 'leaf') {
                    storageData.leafs.push(data);
                }
                showNotification('æ–°å¢æˆåŠŸï¼', 'success');
            }

            saveToStorage();
            resetForm();
            updateStats();
            renderLocations();
        }

        // æ›´æ–°é …ç›®
        function updateItem(type, data) {
            let array;
            if (type === 'root') array = storageData.roots;
            else if (type === 'node') array = storageData.nodes;
            else if (type === 'leaf') array = storageData.leafs;
            else if (type === 'temp') array = storageData.tempStorage;

            const index = array.findIndex(item => item.id === data.id);
            if (index !== -1) {
                // ä¿ç•™åŸæœ‰çš„çˆ¶ç´šé—œä¿‚
                if (!data.parentType && array[index].parentType) {
                    data.parentType = array[index].parentType;
                    data.parentId = array[index].parentId;
                }
                // ä¿ç•™åŸæœ‰çš„å®¹å™¨é™åˆ¶åœ°é»ï¼ˆå¦‚æœæ–°æ•¸æ“šä¸­æ²’æœ‰æ˜ç¢ºè¨­ç½®ï¼‰
                if (type === 'node' && !('restrictedRootId' in data) && 'restrictedRootId' in array[index]) {
                    data.restrictedRootId = array[index].restrictedRootId;
                }
                array[index] = data;
            }
        }

        // ç·¨è¼¯é …ç›®
        function editItem(type, id) {
            let item;
            if (type === 'root') item = storageData.roots.find(r => r.id === id);
            else if (type === 'node') item = storageData.nodes.find(n => n.id === id);
            else if (type === 'leaf') item = storageData.leafs.find(l => l.id === id);

            if (item) {
                // è‡ªå‹•åˆ‡æ›åˆ°"æ·»åŠ é …ç›®"åˆ†é 
                switchTab('form');

                document.getElementById('itemType').value = type;
                updateFormFields();

                document.getElementById('editId').value = item.id;
                document.getElementById('editType').value = type;
                document.getElementById('itemName').value = item.name;
                document.getElementById('description').value = item.description || '';

                // æ›´æ–°æ¨™ç±¤ç³»çµ±
                currentTags = item.tags ? [...item.tags] : [];
                renderTags();
                // document.getElementById('tags').value = item.tags ? item.tags.join(', ') : ''; // å·²ç”± renderTags è™•ç†

                if (type === 'leaf') {
                    document.getElementById('itemQuantity').value = item.quantity || 1;
                }

                if (type === 'node') {
                    const filterSelect = document.getElementById('filterLocationId');
                    if (filterSelect) {
                        filterSelect.value = item.restrictedRootId ? `root-${item.restrictedRootId}` : '';
                        populateParentOptions('node');
                    }
                }

                if (item.parentType && item.parentId) {
                    document.getElementById('parentId').value = `${item.parentType}-${item.parentId}`;
                }

                // é¡¯ç¤ºç·¨è¼¯æ©«å¹…
                document.getElementById('formTitle').textContent = 'âœï¸ ç·¨è¼¯é …ç›®';
                document.getElementById('editBannerText').textContent = `âœï¸ æ­£åœ¨ç·¨è¼¯ï¼š${item.name}`;
                document.getElementById('editBanner').style.display = 'flex';

                currentEditId = id;
                currentEditType = type;

                // æ»¾å‹•åˆ°è¡¨å–®
                document.querySelector('.form-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        // åˆªé™¤é …ç›®
        function deleteItem(type, id) {
            let item;
            let itemName;
            if (type === 'root') {
                item = storageData.roots.find(r => r.id === id);
                itemName = item?.name || 'è©²åœ°é»';
            } else if (type === 'node') {
                item = storageData.nodes.find(n => n.id === id);
                itemName = item?.name || 'è©²å®¹å™¨';
            } else if (type === 'leaf') {
                item = storageData.leafs.find(l => l.id === id);
                itemName = item?.name || 'è©²ç‰©ä»¶';
            }

            // æª¢æŸ¥æ˜¯å¦æœ‰å­é …ç›®
            let hasChildren = false;
            let childCount = 0;

            if (type === 'root') {
                const children = storageData.nodes.filter(n => n.parentType === 'root' && n.parentId === id);
                hasChildren = children.length > 0;
                childCount = countRootItems(id);
            } else if (type === 'node') {
                const childNodes = storageData.nodes.filter(n => n.parentType === 'node' && n.parentId === id);
                const childLeafs = storageData.leafs.filter(l => l.parentType === 'node' && l.parentId === id);
                hasChildren = childNodes.length > 0 || childLeafs.length > 0;
                childCount = countNodeItems(id);
            }

            let message = `ç¢ºå®šè¦åˆªé™¤ã€Œ${itemName}ã€å—ï¼Ÿ`;
            if (hasChildren) {
                message = `ã€Œ${itemName}ã€ä¸‹æœ‰ ${childCount} å€‹é …ç›®ï¼Œåˆªé™¤å°‡æœƒä¸€ä½µåˆªé™¤æ‰€æœ‰å­é …ç›®ã€‚\n\nç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ`;
            }

            if (!confirm(message)) {
                return;
            }

            // åŸ·è¡Œåˆªé™¤
            if (hasChildren) {
                deleteItemAndChildren(type, id);
            } else {
                removeItem(type, id);
            }

            saveToStorage();
            updateStats();
            renderLocations();
            showNotification('åˆªé™¤æˆåŠŸ', 'success');

            // å¦‚æœæ­£åœ¨ç·¨è¼¯è©²é …ç›®ï¼Œé‡ç½®è¡¨å–®
            if (currentEditId === id) {
                resetForm();
            }
        }

        // éæ­¸åˆªé™¤é …ç›®åŠå…¶å­é …ç›®
        function deleteItemAndChildren(type, id) {
            if (type === 'root') {
                const childNodes = storageData.nodes.filter(n => n.parentType === 'root' && n.parentId === id);
                childNodes.forEach(node => deleteItemAndChildren('node', node.id));
                removeItem('root', id);
            } else if (type === 'node') {
                const childNodes = storageData.nodes.filter(n => n.parentType === 'node' && n.parentId === id);
                childNodes.forEach(node => deleteItemAndChildren('node', node.id));
                const childLeafs = storageData.leafs.filter(l => l.parentType === 'node' && l.parentId === id);
                childLeafs.forEach(leaf => removeItem('leaf', leaf.id));
                removeItem('node', id);
            }
        }

        // ç§»é™¤å–®å€‹é …ç›®
        function removeItem(type, id) {
            if (type === 'root') {
                storageData.roots = storageData.roots.filter(r => r.id !== id);
                expandedLocations.delete(id);
            } else if (type === 'node') {
                storageData.nodes = storageData.nodes.filter(n => n.id !== id);
            } else if (type === 'leaf') {
                storageData.leafs = storageData.leafs.filter(l => l.id !== id);
            }
        }

        // é‡ç½®è¡¨å–®
        function resetForm() {
            document.getElementById('dataForm').reset();
            document.getElementById('editId').value = '';
            document.getElementById('editType').value = '';
            document.getElementById('parentField').style.display = 'none';
            document.getElementById('parentId').required = false;
            document.getElementById('formTitle').textContent = 'â• æ·»åŠ é …ç›®';
            document.getElementById('editBanner').style.display = 'none';
            currentEditId = null;
            currentEditType = null;

            // é‡ç½®æ¨™ç±¤
            currentTags = [];
            renderTags();
        }

        // å–æ¶ˆç·¨è¼¯
        function cancelEdit() {
            resetForm();
        }

        // æœç´¢éæ¿¾ (Debounced)
        function filterLocations(searchText) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                // æœç´¢å‰æ”¶èµ·æ‰€æœ‰å·²æ‰“é–‹çš„å®¹å™¨ä¸¦å–æ¶ˆæ¿€æ´»
                if (searchText && searchText.trim() !== '') {
                    expandedNodes.clear();  // æ”¶èµ·æ‰€æœ‰å®¹å™¨
                    selectedNodeId = null;  // å–æ¶ˆé¸ä¸­çš„ç¯€é» (ç§»é™¤ selected-node class)
                }
                renderLocations(searchText);
            }, 300);
        }

        // åŸ·è¡Œæœç´¢é è¨ˆç®—
        function performSearch(searchText) {
            const searchLower = searchText.toLowerCase();
            searchResults.matchingLeafIds.clear();
            searchResults.matchingNodeIds.clear();
            searchResults.nodesWithMatches.clear();
            searchResults.rootsWithMatches.clear();
            nodeMap.clear();

            if (!searchText) return;

            // å»ºç«‹ Node Map
            storageData.nodes.forEach(n => nodeMap.set(n.id, n));

            // 1. æŸ¥æ‰¾ç›´æ¥åŒ¹é…
            storageData.leafs.forEach(l => {
                if (l.name.toLowerCase().includes(searchLower) || (l.description && l.description.toLowerCase().includes(searchLower))) {
                    searchResults.matchingLeafIds.add(l.id);
                }
            });
            storageData.nodes.forEach(n => {
                if (n.name.toLowerCase().includes(searchLower)) {
                    searchResults.matchingNodeIds.add(n.id);
                }
            });

            // 2. å‘ä¸Šå‚³æ’­æ¨™è¨˜
            const markAncestors = (parentType, parentId) => {
                if (parentType === 'node') {
                    if (searchResults.nodesWithMatches.has(parentId)) return; // å·²æ¨™è¨˜ï¼Œç„¡éœ€é‡è¤‡éæ­·
                    searchResults.nodesWithMatches.add(parentId);

                    const parentNode = nodeMap.get(parentId);
                    if (parentNode) {
                        markAncestors(parentNode.parentType, parentNode.parentId);
                    }
                } else if (parentType === 'root') {
                    searchResults.rootsWithMatches.add(parentId);
                }
            };

            // è™•ç†åŒ¹é…çš„ç‰©ä»¶
            storageData.leafs.forEach(l => {
                if (searchResults.matchingLeafIds.has(l.id)) {
                    markAncestors(l.parentType, l.parentId);
                }
            });

            // è™•ç†åŒ¹é…çš„ç¯€é»
            storageData.nodes.forEach(n => {
                if (searchResults.matchingNodeIds.has(n.id)) {
                    markAncestors(n.parentType, n.parentId);
                }
            });
        }

        // å°å‡º JSON
        function exportToJSON() {
            const dataStr = JSON.stringify(storageData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `storage_export_${getDateString()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('å°å‡ºæˆåŠŸï¼', 'success');
        }

        // å°å…¥æ•¸æ“š
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (importedData.roots && importedData.nodes && importedData.leafs) {
                        if (confirm('ç¢ºå®šè¦å°å…¥æ•¸æ“šå—ï¼Ÿé€™å°‡è¦†è“‹ç¾æœ‰æ•¸æ“šã€‚')) {
                            storageData = importedData;
                            expandedLocations.clear();
                            saveToStorage();
                            updateStats();
                            renderLocations();
                            showNotification('å°å…¥æˆåŠŸï¼', 'success');
                        }
                    } else {
                        alert('å°å…¥å¤±æ•—ï¼šæ–‡ä»¶æ ¼å¼ä¸æ­£ç¢ºï¼');
                    }
                } catch (error) {
                    alert('å°å…¥å¤±æ•—ï¼šæ–‡ä»¶æ ¼å¼ä¸æ­£ç¢ºï¼');
                    console.error(error);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // é‚„åŸç¯„æœ¬æ•¸æ“š
        function restoreTemplate() {
            if (confirm('ç¢ºå®šè¦é‚„åŸç‚ºç¯„æœ¬æ•¸æ“šå—ï¼Ÿé€™å°‡æ¸…é™¤æ‰€æœ‰ç•¶å‰æ•¸æ“šä¸¦æ¢å¾©é è¨­å€¼ã€‚')) {
                localStorage.removeItem(STORAGE_KEY);
                loadData(); // é‡æ–°è¼‰å…¥æœƒè§¸ç™¼é è¨­æ•¸æ“šåˆå§‹åŒ–
                expandedLocations.clear();
                updateStats();
                renderLocations();
                renderTempStorage();
                resetForm();
                showNotification('å·²é‚„åŸç‚ºç¯„æœ¬æ•¸æ“š', 'success');
            }
        }

        // æ¸…ç©ºæ‰€æœ‰æ•¸æ“š
        function clearAllData() {
            if (confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰æ•¸æ“šå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¾©ï¼')) {
                storageData = { roots: [], nodes: [], leafs: [], tempStorage: [] };
                expandedLocations.clear();
                saveToStorage();
                updateStats();
                renderLocations();
                renderTempStorage();
                resetForm();
                showNotification('æ•¸æ“šå·²æ¸…ç©º', 'success');
            }
        }

        // æ¸²æŸ“ä¸´æ—¶å­˜å‚¨é¢æ¿
        function renderTempStorage() {
            const container = document.getElementById('tempStorageList');
            if (!storageData.tempStorage || storageData.tempStorage.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px 20px; color: #b45309;">
                        <p style="font-size: 14px; margin-bottom: 10px;">ğŸ“‹ è‡¨æ™‚å­˜å„²å€</p>
                        <p style="font-size: 12px; color: #d97706;">åœ¨æ­¤å‰µå»ºæœªåˆ†é¡çš„å®¹å™¨/ç‰©ä»¶</p>
                        <p style="font-size: 12px; color: #d97706; margin-top: 10px;">æˆ–æ‹–å‹•é …ç›®åˆ°æ­¤è™•</p>
                    </div>
                    <div class="temp-add-section">
                        <button class="btn-add-temp-item" onclick="addTempItem()">+ æ·»åŠ è‡¨æ™‚é …ç›®</button>
                    </div>
                `;
                return;
            }

            const items = storageData.tempStorage.map(item => {
                const isNode = item.type === 'node';
                let hasChildren = false;
                let isExpanded = false;
                let childNodes = [];
                let childLeafs = [];

                if (isNode) {
                    childNodes = storageData.nodes.filter(n => n.parentType === 'node' && n.parentId === item.id);
                    childLeafs = storageData.leafs.filter(l => l.parentType === 'node' && l.parentId === item.id);
                    hasChildren = childNodes.length > 0 || childLeafs.length > 0;
                    isExpanded = expandedNodes.has(item.id);
                }

                const icon = isNode ? 'ğŸ“¦' : 'ğŸ”–';
                const typeLabel = isNode ? 'å®¹å™¨' : 'ç‰©ä»¶';
                const shouldBeFullWidth = isExpanded && hasChildren;
                const wrapperStyle = shouldBeFullWidth ? 'grid-column: 1 / -1; width: 100%;' : '';
                const cardStyle = shouldBeFullWidth ? 'aspect-ratio: auto; flex-direction: row; justify-content: flex-start; padding: 10px 20px; gap: 15px; height: auto;' : '';
                const infoStyle = shouldBeFullWidth ? 'align-items: flex-start; text-align: left;' : '';
                const nameStyle = shouldBeFullWidth ? 'text-align: left;' : '';

                return `
                    <div class="temp-item-wrapper" style="${wrapperStyle}">
                        <div class="temp-item-card"
                             draggable="true"
                             onmouseenter="showHoverPopup(event, 'temp', '${item.id}')"
                             onmouseleave="hideHoverPopup()"
                             ondragstart="handleDragStart(event, 'temp', '${item.id}')"
                             ${isNode ? `ondrop="handleDrop(event, 'node', '${item.id}')"` : ''}
                             style="${cardStyle}"
                             ${isNode && hasChildren ? `onclick="toggleNode('${item.id}'); event.stopPropagation();"` : ''}>

                            ${isNode && hasChildren ? `
                                <button class="node-toggle" onclick="toggleNode('${item.id}'); event.stopPropagation();" style="position: absolute; top: 5px; left: 5px;">
                                    ${isExpanded ? 'â–¼' : 'â–¶'}
                                </button>
                            ` : ''}

                            <div class="temp-item-icon">${icon}</div>
                            <div class="temp-item-info" style="${infoStyle}">
                                <div class="temp-item-name" style="${nameStyle}">${item.name}</div>
                                <span class="temp-item-type">${typeLabel}</span>
                            </div>
                            <div class="temp-item-actions">
                                <button class="btn-mini" onclick="editTempItem('${item.id}'); event.stopPropagation();" title="ç·¨è¼¯">âœï¸</button>
                                <button class="btn-mini" onclick="deleteTempItem('${item.id}'); event.stopPropagation();" title="åˆªé™¤">ğŸ—‘ï¸</button>
                            </div>
                        </div>

                        ${isExpanded && hasChildren ? `
                            <div class="node-children" style="background: rgba(255,255,255,0.5); border-radius: 8px; padding: 10px; margin-top: 5px; border: 1px dashed #ccc;">
                                <div class="node-children-grid"
                                     ondragover="handleDragOver(event)"
                                     ondrop="handleDrop(event, 'node', '${item.id}')">
                                    ${renderMixedItems(childNodes, childLeafs, 1, item.id)}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                ${items}
                <div class="temp-add-section">
                    <button class="btn-add-temp-item" onclick="addTempItem()">+ æ·»åŠ è‡¨æ™‚é …ç›®</button>
                </div>
            `;
        }

        // æ·»åŠ ä¸´æ—¶é¡¹ç›®
        function addTempItem() {
            document.getElementById('itemType').value = 'node';
            updateFormFields();

            // è®¾ç½®ä¸€ä¸ªç‰¹æ®Šæ ‡è®°ï¼Œè¡¨ç¤ºè¦æ·»åŠ åˆ°ä¸´æ—¶å­˜å‚¨
            document.getElementById('editId').value = '';
            document.getElementById('editType').value = 'temp';

            // éšè—çˆ¶çº§é€‰æ‹©å¹¶ç§»é™¤ required å±æ€§
            const parentField = document.getElementById('parentField');
            const parentSelect = document.getElementById('parentId');
            parentField.style.display = 'none';
            parentSelect.removeAttribute('required');

            document.getElementById('formTitle').textContent = 'â• æ·»åŠ è‡¨æ™‚é …ç›®';
            document.querySelector('.form-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // ç¼–è¾‘ä¸´æ—¶é¡¹ç›®
        function editTempItem(id) {
            const item = storageData.tempStorage.find(i => i.id === id);
            if (item) {
                document.getElementById('itemType').value = item.type;
                updateFormFields();

                document.getElementById('editId').value = item.id;
                document.getElementById('editType').value = 'temp';
                document.getElementById('itemName').value = item.name;
                document.getElementById('description').value = item.description || '';

                // æ›´æ–°æ¨™ç±¤ç³»çµ±
                currentTags = item.tags ? [...item.tags] : [];
                renderTags();
                // document.getElementById('tags').value = item.tags ? item.tags.join(', ') : ''; // å·²ç”± renderTags è™•ç†

                if (item.type === 'leaf') {
                    document.getElementById('itemQuantity').value = item.quantity || 1;
                }

                // éšè—çˆ¶çº§é€‰æ‹©å¹¶ç§»é™¤ required å±æ€§
                const parentField = document.getElementById('parentField');
                const parentSelect = document.getElementById('parentId');
                parentField.style.display = 'none';
                parentSelect.removeAttribute('required');

                document.getElementById('formTitle').textContent = 'âœï¸ ç·¨è¼¯è‡¨æ™‚é …ç›®';
                document.getElementById('editBannerText').textContent = `âœï¸ æ­£åœ¨ç·¨è¼¯ï¼š${item.name}`;
                document.getElementById('editBanner').style.display = 'flex';

                currentEditId = id;
                currentEditType = 'temp';

                document.querySelector('.form-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        // åˆ é™¤ä¸´æ—¶é¡¹ç›®
        function deleteTempItem(id) {
            const item = storageData.tempStorage.find(i => i.id === id);
            if (item && confirm(`ç¢ºå®šè¦åˆªé™¤è‡¨æ™‚é …ç›®ã€Œ${item.name}ã€å—ï¼Ÿ`)) {
                storageData.tempStorage = storageData.tempStorage.filter(i => i.id !== id);
                saveToStorage();
                renderTempStorage();
                showNotification('å·²åˆªé™¤è‡¨æ™‚é …ç›®', 'success');
            }
        }

        // æ‹–æ”¾åŠŸèƒ½
        let dragData = null;

        function handleDragStart(event, type, id) {
            event.stopPropagation();
            dragData = { type, id };
            event.dataTransfer.effectAllowed = 'move';
            event.currentTarget.style.opacity = '0.5';
        }

        function handleNodeDragStart(event, nodeId, isExpanded) {
            // å¦‚æœ node å·²æ‰“é–‹ï¼Œåªèƒ½å¾ header æ‹–æ‹‰
            if (isExpanded) {
                // æª¢æŸ¥æ‹–æ‹½èµ·é»æ˜¯å¦åœ¨ header å€åŸŸ
                const isFromHeader = event.target.closest('.node-card-header') !== null;

                if (!isFromHeader) {
                    // ä¸æ˜¯å¾ header æ‹–æ‹‰ï¼Œé˜»æ­¢æ‹–æ‹½
                    event.stopPropagation();
                    return;
                }
            }
            handleDragStart(event, 'node', nodeId);
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            // æ·»åŠ è§†è§‰åé¦ˆ
            const target = event.currentTarget;
            // ç°¡å–®å„ªåŒ–ï¼šå¦‚æœå·²ç¶“æœ‰é¡åˆ¥ï¼Œå°±ä¸é‡è¤‡æ·»åŠ 
            if (!target.classList.contains('drag-over')) {
                if (target.classList.contains('temp-storage-content') ||
                    target.classList.contains('location-detail-expanded') ||
                    target.classList.contains('location-grid-item') ||
                    target.classList.contains('node-card') ||
                    target.classList.contains('leaf-card') ||
                    target.classList.contains('node-children-grid')) {
                    target.classList.add('drag-over');
                }
            }

            return false;
        }

        function handleDrop(event, targetType, targetId) {
            event.preventDefault();
            event.stopPropagation();

            // ç§»é™¤æ‰€æœ‰è¦–è¦ºåé¥‹
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            if (!dragData) return;

            const { type: sourceType, id: sourceId } = dragData;

            // æ‰¾åˆ°æºé¡¹ç›®
            let sourceItem = null;
            let sourceArray = null;

            if (sourceType === 'temp') {
                sourceItem = storageData.tempStorage.find(i => i.id === sourceId);
                sourceArray = storageData.tempStorage;
            } else if (sourceType === 'node') {
                sourceItem = storageData.nodes.find(n => n.id === sourceId);
                sourceArray = storageData.nodes;
            } else if (sourceType === 'leaf') {
                sourceItem = storageData.leafs.find(l => l.id === sourceId);
                sourceArray = storageData.leafs;
            }

            if (!sourceItem) return;

            // ç¢ºå®šæ–°çš„çˆ¶ç´šé—œä¿‚
            let newParentType, newParentId;
            let newTimestamp = new Date().toISOString(); // é»˜èªç‚ºç•¶å‰æ™‚é–“ï¼ˆæ·»åŠ åˆ°æœ«å°¾ï¼‰

            if (targetType === 'leaf') {
                // æ‹–åˆ°ç‰©ä»¶ä¸Šï¼šæ’å…¥åˆ°è©²ç‰©ä»¶ä¹‹å‰
                const targetLeaf = storageData.leafs.find(l => l.id === targetId);
                if (!targetLeaf) return;
                newParentType = targetLeaf.parentType;
                newParentId = targetLeaf.parentId;

                // å¦‚æœæ˜¯åŒé¡å‹ï¼ˆLeafæ‹–åˆ°Leafï¼‰ï¼Œè¨ˆç®—æ’å…¥ä½ç½®çš„æ™‚é–“æˆ³
                if (sourceType === 'leaf') {
                    const siblings = storageData.leafs.filter(l =>
                        l.parentType === newParentType &&
                        l.parentId === newParentId &&
                        l.id !== sourceId
                    ).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                    const targetIndex = siblings.findIndex(l => l.id === targetId);

                    if (targetIndex !== -1) {
                        if (targetIndex === 0) {
                            // æ’å…¥åˆ°æœ€å‰é¢
                            const firstTimestamp = new Date(siblings[0].timestamp).getTime();
                            newTimestamp = new Date(firstTimestamp - 100000).toISOString();
                        } else {
                            // æ’å…¥åˆ°ä¸­é–“
                            const prevTimestamp = new Date(siblings[targetIndex - 1].timestamp).getTime();
                            const nextTimestamp = new Date(siblings[targetIndex].timestamp).getTime();
                            newTimestamp = new Date((prevTimestamp + nextTimestamp) / 2).toISOString();
                        }
                    }
                }
            } else if (targetType === 'node') {
                // æ‹–åˆ°å®¹å™¨ä¸Šï¼šæˆç‚ºè©²å®¹å™¨çš„å­é …ï¼ˆæ·»åŠ åˆ°æœ«å°¾ï¼‰
                newParentType = 'node';
                newParentId = targetId;
            } else if (targetType === 'root') {
                // æ‹–åˆ°åœ°é»ä¸Šï¼šæˆç‚ºè©²åœ°é»çš„å­é …ï¼ˆæ·»åŠ åˆ°æœ«å°¾ï¼‰
                newParentType = 'root';
                newParentId = targetId;
            }

            // å¾ªç’°å¼•ç”¨æª¢æŸ¥ (Circular Reference Check)
            if (sourceType === 'node') {
                // 1. ä¸èƒ½æ‹–åˆ°è‡ªå·±è£¡é¢ (Target is self)
                if (newParentType === 'node' && newParentId === sourceId) {
                    return;
                }

                // 2. ä¸èƒ½æ‹–åˆ°è‡ªå·±çš„å­å­«ç¯€é»è£¡é¢ (Target is descendant)
                if (newParentType === 'node') {
                    if (isAncestorOf(sourceId, newParentId)) {
                        alert('ç„¡æ³•ç§»å‹•ï¼šä¸èƒ½å°‡å®¹å™¨ç§»åˆ°å…¶è‡ªèº«çš„å­å®¹å™¨ä¸­ã€‚');
                        return;
                    }
                }
            }            // è¨˜éŒ„ç§»å‹•å‰çš„è·¯å¾‘
            const sourcePath = getLogPath(sourceType, sourceId);

            // æª¢æŸ¥è·¯å¾‘æ˜¯å¦æ”¹è®Š
            const oldParentType = sourceItem.parentType;
            const oldParentId = sourceItem.parentId;
            const isPathChanged = (sourceType === 'temp') || (oldParentType !== newParentType || oldParentId !== newParentId);

            // Create new item object
            const newItem = {
                id: sourceItem.id,
                name: sourceItem.name,
                description: sourceItem.description || '',
                tags: sourceItem.tags || [],
                timestamp: newTimestamp
            };

            if (sourceItem.quantity) {
                newItem.quantity = sourceItem.quantity;
            }

            // Set new parent relationship
            newItem.parentType = newParentType;
            newItem.parentId = newParentId;

            // ä»æºä½ç½®åˆ é™¤
            if (sourceType === 'temp') {
                // ä»ä¸´æ—¶å­˜å‚¨ç§»åˆ°èŠ‚ç‚¹
                storageData.tempStorage = storageData.tempStorage.filter(i => i.id !== sourceId);

                if (sourceItem.type === 'node') {
                    storageData.nodes.push(newItem);
                } else {
                    storageData.leafs.push(newItem);
                }
            } else {
                // åœ¨nodes/leafsä¹‹é—´ç§»åŠ¨ï¼Œæ›´æ–°çˆ¶çº§å…³ç³»
                const index = sourceArray.findIndex(i => i.id === sourceId);
                if (index !== -1) {
                    // ç§»é™¤èˆŠé …ç›®ä¸¦æ·»åŠ åˆ°æ•¸çµ„æœ«å°¾ï¼Œç¢ºä¿å®ƒé¡¯ç¤ºåœ¨åˆ—è¡¨æœ€å¾Œ
                    sourceArray.splice(index, 1);
                    sourceArray.push(newItem);
                }
            }

            saveToStorage();
            updateStats();
            renderLocations();
            renderTempStorage();

            if (isPathChanged) {
                showNotification('é …ç›®å·²ç§»å‹•', 'success');
                // æ‰“å°ç§»å‹•è·¯å¾‘æ—¥èªŒ
                let finalType = sourceType === 'temp' ? sourceItem.type : sourceType;
                const targetPath = getLogPath(finalType, sourceId);
                console.log(`Moved "${sourceItem.name}": ${sourcePath} => ${targetPath}`);
            } else {
                // åƒ…æ’åºæ”¹è®Šï¼Œä¸é¡¯ç¤ºç§»å‹•é€šçŸ¥
                console.log(`Reordered "${sourceItem.name}"`);
            }

            // é‡ç½®æ‹–æ‹½çŠ¶æ€
            dragData = null;
        }

        function handleDropToTemp(event) {
            event.preventDefault();
            event.stopPropagation();

            // ç§»é™¤æ‰€æœ‰è¦–è¦ºåé¥‹
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            if (!dragData) return;

            const { type: sourceType, id: sourceId } = dragData;

            // åªå…è®¸ä»nodes/leafsæ‹–åˆ°ä¸´æ—¶å­˜å‚¨
            if (sourceType === 'temp') {
                dragData = null;
                return;
            }

            // è¨˜éŒ„ç§»å‹•å‰çš„è·¯å¾‘
            const sourcePath = getLogPath(sourceType, sourceId);

            let sourceItem = null;

            if (sourceType === 'node') {
                sourceItem = storageData.nodes.find(n => n.id === sourceId);
                if (sourceItem) {
                    // ä»nodesåˆ é™¤
                    storageData.nodes = storageData.nodes.filter(n => n.id !== sourceId);

                    // æ·»åŠ åˆ°ä¸´æ—¶å­˜å‚¨
                    storageData.tempStorage.push({
                        id: sourceItem.id,
                        name: sourceItem.name,
                        description: sourceItem.description || '',
                        tags: sourceItem.tags || [],
                        timestamp: sourceItem.timestamp,
                        type: 'node'
                    });
                }
            } else if (sourceType === 'leaf') {
                sourceItem = storageData.leafs.find(l => l.id === sourceId);
                if (sourceItem) {
                    // ä»leafsåˆ é™¤
                    storageData.leafs = storageData.leafs.filter(l => l.id !== sourceId);

                    // æ·»åŠ åˆ°ä¸´æ—¶å­˜å‚¨
                    storageData.tempStorage.push({
                        id: sourceItem.id,
                        name: sourceItem.name,
                        description: sourceItem.description || '',
                        tags: sourceItem.tags || [],
                        timestamp: sourceItem.timestamp,
                        quantity: sourceItem.quantity || 1,
                        type: 'leaf'
                    });
                }
            }

            if (sourceItem) {
                saveToStorage();
                updateStats();
                renderLocations();
                renderTempStorage();
                showNotification('é …ç›®å·²ç§»è‡³è‡¨æ™‚å­˜å„²', 'success');

                console.log(`Moved "${sourceItem.name}": ${sourcePath} => è‡¨æ™‚å­˜å„²`);
            }

            // é‡ç½®æ‹–æ‹½çŠ¶æ€
            dragData = null;
        }

        // æ·»åŠ æ‹–æ‹½ç»“æŸäº‹ä»¶å¤„ç†
        document.addEventListener('dragend', function(event) {
            if (event.target.classList.contains('node-card') ||
                event.target.classList.contains('leaf-card') ||
                event.target.classList.contains('temp-item-card')) {
                event.target.style.opacity = '1';
            }

            // ç§»é™¤æ‰€æœ‰è¦–è¦ºåé¥‹
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            dragData = null;
        });

        // æ·»åŠ æ‹–æ‹½ç¦»å¼€äº‹ä»¶å¤„ç†
        document.addEventListener('dragleave', function(event) {
            if (event.target.classList.contains('drag-over')) {
                event.target.classList.remove('drag-over');
            }
        });

        // ç²å–æ—¥æœŸå­—ç¬¦ä¸²
        function getDateString() {
            const now = new Date();
            return `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
        }

        // é¡¯ç¤º Hover Popup
        function showHoverPopup(event, type, id) {
            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢è§¸ç™¼çˆ¶å±¤çš„ popup
            if (event && event.stopPropagation) {
                event.stopPropagation();
            }

            // ç§»é™¤èˆŠçš„ popup
            const oldPopup = document.getElementById('hoverPopup');
            if (oldPopup) oldPopup.remove();

            let item = null;
            if (type === 'root') {
                item = storageData.roots.find(r => r.id === id);
            } else if (type === 'node') {
                item = storageData.nodes.find(n => n.id === id);
            } else if (type === 'leaf') {
                item = storageData.leafs.find(l => l.id === id);
            } else if (type === 'temp') {
                item = storageData.tempStorage.find(t => t.id === id);
            }

            if (!item) return;

            // åˆ¤æ–·æ˜¯å¦ç‚ºç‰©ä»¶é¡å‹ (leaf æˆ– temp ä¸­çš„ leaf)
            const isLeaf = type === 'leaf' || (type === 'temp' && item.type === 'leaf');

            // æª¢æŸ¥æ˜¯å¦æœ‰å…§å®¹å¯é¡¯ç¤º
            // å¦‚æœæ˜¯ç‰©ä»¶ï¼Œç¸½æ˜¯é¡¯ç¤ºï¼ˆå› ç‚ºè‡³å°‘æœ‰æ•¸é‡ï¼Œé»˜èªç‚º1ï¼‰
            const hasContent = item.description || (item.tags && item.tags.length > 0) || isLeaf;
            if (!hasContent) return;

            // æ§‹å»º popup å…§å®¹
            let content = '';
            if (item.description) {
                content += `<div class="popup-description">${item.description}</div>`;
            }
            if (item.tags && item.tags.length > 0) {
                content += `<div class="popup-tags">${item.tags.map(tag => `<span class="popup-tag">${tag}</span>`).join('')}</div>`;
            }
            // ç‰©ä»¶ç‰¹æ®Šï¼šé¡¯ç¤ºæ•¸é‡
            if (isLeaf) {
                const qty = item.quantity !== undefined ? item.quantity : 1;
                content += `<div class="popup-quantity">æ•¸é‡: ${qty} å€‹</div>`;
            }

            // å‰µå»º popup
            const popup = document.createElement('div');
            popup.id = 'hoverPopup';
            popup.innerHTML = content;
            popup.style.cssText = `
                position: fixed;
                background: white;
                border: 1px solid #cbd5e0;
                border-radius: 8px;
                padding: 12px 16px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                max-width: 300px;
                font-size: 13px;
                color: #4a5568;
                z-index: 9999;
                pointer-events: none;
            `;

            document.body.appendChild(popup);

            // è¨ˆç®—ä½ç½®ï¼ˆé¡¯ç¤ºåœ¨å³é‚Šï¼‰
            // ä½¿ç”¨ currentTarget ç¢ºä¿å®šä½æ˜¯ç›¸å°æ–¼æ•´å€‹å¡ç‰‡ï¼Œè€Œä¸æ˜¯å…§éƒ¨çš„å­å…ƒç´ 
            const targetEl = event.currentTarget || event.target;
            const rect = targetEl.getBoundingClientRect();
            let top = rect.top + rect.height / 2 - popup.offsetHeight / 2;
            let left = rect.right + 10;

            // é˜²æ­¢è¶…å‡ºè¦–çª—
            if (left + 300 > window.innerWidth) {
                left = rect.left - 310;
            }
            if (top < 10) {
                top = 10;
            } else if (top + popup.offsetHeight > window.innerHeight - 10) {
                top = window.innerHeight - popup.offsetHeight - 10;
            }

            popup.style.top = top + 'px';
            popup.style.left = left + 'px';
        }

        // éš±è— Hover Popup
        function hideHoverPopup() {
            const popup = document.getElementById('hoverPopup');
            if (popup) popup.remove();
        }

        // é¡¯ç¤ºé€šçŸ¥
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#48bb78' : '#f56565'};
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
                font-weight: 600;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(400px)';
                notification.style.transition = 'all 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // ========== æ¨™ç±¤é åˆ‡æ›åŠŸèƒ½ ==========
        function switchTab(tabName) {
            // åˆ‡æ›æ¨™ç±¤æŒ‰éˆ•ç‹€æ…‹
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            if (tabName === 'form') {
                document.getElementById('formTab').classList.add('active');
                document.getElementById('formTabContent').classList.add('active');
            } else if (tabName === 'hierarchy') {
                document.getElementById('hierarchyTab').classList.add('active');
                document.getElementById('hierarchyTabContent').classList.add('active');
            }
        }

        // ========== å±¤ç´šæ§‹å»ºå™¨åŠŸèƒ½ ==========

        // åˆå§‹åŒ–å±¤ç´šæ§‹å»ºå™¨ - æ–°è¨­è¨ˆ
        function initializeHierarchy() {
            hierarchyLevels = {
                id: 'root-0',
                level: 1,
                selectedId: null,
                selectedName: null,
                children: [],
                displayName: 'ç¬¬ 1 å±¤ï¼šğŸ  åœ°é»'
            };
            hierarchyLevelCounter = 1;
            renderHierarchyLevels();
        }

        // è™•ç†å±¤ç´šé¸æ“‡è®Šæ›´
        function handleHierarchyChange(levelId, value) {
            const level = findLevelById(levelId);
            if (level) {
                if (level.selectedId !== value) {
                    // æ¸…é™¤æ‰€æœ‰å­å±¤ç´š
                    level.children = [];
                    level.selectedName = null;
                } else {
                    // å–æ¶ˆé¸æ“‡
                    level.selectedId = null;
                    level.selectedName = null;
                    level.children = [];
                    renderHierarchyLevels();
                    return;
                }

                if (value) {
                    level.selectedId = value;
                    const [type, id] = value.split('-');
                    let item;
                    if (type === 'root') {
                        item = storageData.roots.find(r => r.id === id);
                        level.displayName = `ç¬¬ ${level.level} å±¤ï¼šğŸ  ${item?.name || 'æœªçŸ¥'}`;
                    } else {
                        item = storageData.nodes.find(n => n.id === id);
                        level.displayName = `ç¬¬ ${level.level} å±¤ï¼šğŸ“¦ ${item?.name || 'æœªçŸ¥'}`;
                    }
                    level.selectedName = item?.name || null;
                }

                renderHierarchyLevels();
            }
        }

        // æ·»åŠ æ–°å±¤ç´šï¼ˆåŸºæ–¼ç•¶å‰å±¤ç´šï¼‰
        function addHierarchyLevel(levelId) {
            const parentLevel = findLevelById(levelId);
            if (!parentLevel || !parentLevel.selectedId) {
                alert('è«‹å…ˆé¸æ“‡ç•¶å‰å±¤ç´šçš„é …ç›®');
                return;
            }

            const newLevelId = `level-${++hierarchyLevelCounter}`;
            const newLevel = {
                id: newLevelId,
                level: parentLevel.level + 1,
                selectedId: null,
                selectedName: null,
                children: [],
                displayName: `ç¬¬ ${parentLevel.level + 1} å±¤`
            };

            parentLevel.children.push(newLevel);
            renderHierarchyLevels();
        }

        // æŸ¥æ‰¾å±¤ç´šå°è±¡
        function findLevelById(id, currentLevel = hierarchyLevels) {
            if (currentLevel.id === id) return currentLevel;

            if (currentLevel.children && currentLevel.children.length > 0) {
                for (let child of currentLevel.children) {
                    const found = findLevelById(id, child);
                    if (found) return found;
                }
            }

            return null;
        }

        // ç§»é™¤å±¤ç´šåŠå…¶æ‰€æœ‰å­å±¤ç´š
        function removeHierarchyLevel(levelId) {
            function removeFromLevel(parent, id) {
                if (parent.children) {
                    parent.children = parent.children.filter(child => {
                        if (child.id === id) return false;
                        removeFromLevel(child, id);
                        return true;
                    });
                }
            }

            removeFromLevel(hierarchyLevels, levelId);
            renderHierarchyLevels();
        }

        // æ¸²æŸ“å±¤ç´šæ§‹å»ºå™¨ï¼ˆä¸»å‡½æ•¸ï¼‰
        function renderHierarchyLevels() {
            const container = document.getElementById('hierarchyLevels');
            if (!container) return;

            const html = renderHierarchyTree(hierarchyLevels, 0);
            container.innerHTML = html;
        }

        // éæ­¸æ¸²æŸ“å±¤ç´šæ¨¹çµæ§‹
        function renderHierarchyTree(level, depth = 0) {
            const indent = depth > 0 ? 'clamp(20px, 2vw, 30px)' : '0';
            const options = getHierarchyOptionsForLevel(level);
            const hasChildren = level.children && level.children.length > 0;
            const levelDisplay = level.level ? `ç¬¬ ${level.level} å±¤` : 'æ ¹';

            let html = `
            <div class="hierarchy-level-container" style="margin-left: ${indent};">
                <div class="hierarchy-level">
                    <div class="hierarchy-select-wrapper">
                        ${hasChildren ? '<span class="hierarchy-arrow">â–¼</span>' : ''}
                        <select class="hierarchy-select" onchange="handleHierarchyChange('${level.id}', this.value)">
                            <option value="">-- è«‹é¸æ“‡ ${levelDisplay} --</option>
                            ${options}
                        </select>
                        ${depth > 0 ? `<button class="btn-mini" onclick="removeHierarchyLevel('${level.id}'); event.stopPropagation();" title="åˆªé™¤å±¤ç´š">âœ•</button>` : ''}
                    </div>
                </div>`;

            if (hasChildren) {
                html += '<div class="hierarchy-children">';
                level.children.forEach(child => {
                    html += renderHierarchyTree(child, depth + 1);
                });
                html += '</div>';
            }

            if (level.selectedId) {
                html += `
                <button class="btn-add-sublevel-wide" onclick="addHierarchyLevel('${level.id}'); event.stopPropagation();" title="æ·»åŠ å­å±¤ç´š">
                    â• ç‚ºã€Œ${level.selectedName || 'æ­¤é …ç›®'}ã€æ·»åŠ å­å±¤
                </button>`;
            }

            html += `</div>`;
            return html;
        }

        // ç²å–å±¤ç´šçš„é¸é …åˆ—è¡¨
        function getHierarchyOptionsForLevel(level) {
            const isTopLevel = level.level === 1;
            let options = '';

            if (isTopLevel) {
                // ç¬¬ä¸€å±¤ï¼šåœ°é»å’Œå®¹å™¨
                const roots = storageData.roots.map(root =>
                    `<option value="root-${root.id}" ${level.selectedId === `root-${root.id}` ? 'selected' : ''}>
                        ğŸ  ${root.name}
                    </option>`
                ).join('');

                const nodes = storageData.nodes.map(node =>
                    `<option value="node-${node.id}" ${level.selectedId === `node-${node.id}` ? 'selected' : ''}>
                        ğŸ“¦ ${node.name}
                    </option>`
                ).join('');

                options = roots + nodes;
            } else {
                // å­å±¤ç´šï¼šæ ¹æ“šçˆ¶ç´šé™åˆ¶ç¯©é¸å®¹å™¨
                const parentLevel = getParentLevel(level);
                let filteredNodes = storageData.nodes;

                // è¼”åŠ©å‡½æ•¸ï¼šç²å–ç¯€é»æ‰€å±¬çš„åœ°é» ID
                const getRootIdForNode = (nodeId) => {
                    const visited = new Set();
                    let currentNode = storageData.nodes.find(n => n.id === nodeId);

                    while (currentNode) {
                        if (currentNode.parentType === 'root') {
                            return currentNode.parentId;
                        }
                        if (currentNode.parentType === 'node') {
                            if (visited.has(currentNode.parentId)) break;
                            visited.add(currentNode.parentId);
                            currentNode = storageData.nodes.find(n => n.id === currentNode.parentId);
                        } else {
                            break;
                        }
                    }
                    return null;
                };

                let parentRootId = null;
                if (parentLevel && parentLevel.selectedId) {
                    const [parentType, parentId] = parentLevel.selectedId.split('-');
                    if (parentType === 'root') {
                        parentRootId = parentId;
                    } else if (parentType === 'node') {
                        const parentNode = storageData.nodes.find(n => n.id === parentId);
                        // å¦‚æœçˆ¶ç¯€é»æœ‰é™åˆ¶åœ°é»ï¼Œå‰‡ä½¿ç”¨è©²é™åˆ¶
                        if (parentNode && parentNode.restrictedRootId) {
                            parentRootId = parentNode.restrictedRootId;
                        } else {
                            // å¦å‰‡å˜—è©¦æŸ¥æ‰¾å…¶ç•¶å‰æ‰€åœ¨çš„åœ°é»
                            parentRootId = getRootIdForNode(parentId);
                        }
                    }
                }

                filteredNodes = storageData.nodes.filter(node => {
                    // æ’é™¤è‡ªèº«ï¼ˆé˜²æ­¢é¸æ“‡è‡ªå·±ä½œç‚ºå­ç´šï¼‰
                    if (parentLevel && parentLevel.selectedId === `node-${node.id}`) return false;

                    // å¦‚æœç¯€é»æ²’æœ‰è¨­å®šé™åˆ¶ä½ç½®ï¼Œå‰‡ç¸½æ˜¯é¡¯ç¤º
                    if (!node.restrictedRootId) return true;

                    // å¦‚æœç¯€é»æœ‰é™åˆ¶ä½ç½®ï¼Œå‰‡å¿…é ˆåŒ¹é…çˆ¶ç´šçš„åœ°é»
                    if (parentRootId) {
                        return node.restrictedRootId === parentRootId;
                    }

                    // å¦‚æœç„¡æ³•ç¢ºå®šçˆ¶ç´šåœ°é»ï¼Œä¸”ç¯€é»æœ‰é™åˆ¶ï¼Œå‰‡ä¸é¡¯ç¤º
                    return false;
                });

                options = filteredNodes.map(node =>
                    `<option value="node-${node.id}" ${level.selectedId === `node-${node.id}` ? 'selected' : ''}>
                        ğŸ“¦ ${node.name}
                    </option>`
                ).join('');
            }

            return options;
        }

        // ç²å–å±¤ç´šçš„çˆ¶ç´š
        function getParentLevel(level, currentLevel = hierarchyLevels) {
            if (!currentLevel.children) return null;

            for (let child of currentLevel.children) {
                if (child.id === level.id) return currentLevel;
                const found = getParentLevel(level, child);
                if (found) return found;
            }

            return null;
        }

        // é‡ç½®å±¤ç´šæ§‹å»ºå™¨
        function resetHierarchy() {
            if (confirm('ç¢ºå®šè¦é‡ç½®å±¤ç´šæ§‹å»ºå™¨å—ï¼Ÿæ‰€æœ‰é¸æ“‡å°‡è¢«æ¸…é™¤ã€‚')) {
                initializeHierarchy();
                renderHierarchyLevels();
            }
        }

        // ç²å–å®Œæ•´çš„å±¤ç´šè·¯å¾‘
        function getHierarchyPath(level = hierarchyLevels) {
            if (!level.selectedId) return [];

            const [type, id] = level.selectedId.split('-');
            let item;
            if (type === 'root') {
                item = storageData.roots.find(r => r.id === id);
            } else {
                item = storageData.nodes.find(n => n.id === id);
            }

            const path = [{
                type: type,
                id: id,
                name: item?.name || 'æœªçŸ¥',
                icon: type === 'root' ? 'ğŸ ' : 'ğŸ“¦'
            }];

            if (level.children && level.children.length > 0) {
                level.children.forEach(child => {
                    path.push(...getHierarchyPath(child));
                });
            }

            return path;
        }

        // ä¿å­˜å±¤ç´šçµæ§‹
        function saveHierarchy() {
            const path = getHierarchyPath();

            if (path.length === 0) {
                alert('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹åœ°é»æˆ–å®¹å™¨ï¼');
                return;
            }

            const pathDisplay = path.map(p => `${p.icon} ${p.name}`).join(' â†’ ');
            showNotification(`å·²æ§‹å»ºå±¤ç´šï¼š${pathDisplay}`, 'success');
            console.log('å®Œæ•´å±¤ç´šè·¯å¾‘ï¼š', path);
        }
    </script>

    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</body>
</html>
